<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Cat Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: monospace;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #gameContainer {
            display: flex;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            transition: all 0.3s ease;
            position: relative;
        }
        
        #gameContainer.fullscreen #leftPanel {
            display: none;
        }
        
        #gameContainer.fullscreen #gameArea {
            background: #000;
        }
        
        #leftPanel {
            width: 350px;
            background: #16213e;
            overflow-y: auto;
            padding: 10px;
            border-right: 2px solid #0f3460;
            transition: transform 0.3s ease;
        }
        
        #leftPanel.hidden {
            display: none;
        }
        
        #gameArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 2px solid #0f3460;
            display: block;
            touch-action: none;
        }
        
        /* Remove border on mobile for full viewport usage */
        @media (max-width: 768px) {
            canvas {
                border: none;
            }
        }
        
        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .tab-button {
            flex: 1;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: none;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .tab-button:hover {
            background: #1e5f8e;
        }
        
        .tab-button.active {
            background: #e94560;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            background: #0f3460;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        
        .section h3 {
            margin-bottom: 10px;
            color: #f39c12;
            font-size: 14px;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 12px;
            color: #aaa;
        }
        
        input[type="range"],
        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: 4px;
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #333;
            font-family: monospace;
            font-size: 12px;
        }
        
        input[type="file"] {
            width: 100%;
            margin-bottom: 5px;
            font-size: 11px;
        }
        
        button {
            padding: 6px 12px;
            background: #e94560;
            color: #fff;
            border: none;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            margin: 2px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #ff6b6b;
        }
        
        .sprite-preview {
            background: #222;
            border: 1px solid #444;
            margin: 5px 0;
            padding: 5px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .grid-cell {
            display: inline-block;
            margin: 2px;
            padding: 5px;
            background: #1a1a2e;
            border: 1px solid #444;
        }
        
        .cell-controls {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .cell-controls input[type="number"] {
            width: 60px;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            color: #fff;
            font-size: 14px;
            z-index: 100;
        }
        
        #debugOverlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            color: #0f0;
            font-size: 11px;
            font-family: monospace;
            display: none;
            z-index: 100;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 5px 0;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
            padding: 5px;
            background: #1e5f8e;
            margin-bottom: 5px;
        }
        
        .collapsible:after {
            content: ' ▼';
        }
        
        .collapsible.collapsed:after {
            content: ' ▶';
        }
        
        .collapsible-content {
            transition: max-height 0.3s;
            overflow: hidden;
        }
        
        .collapsed + .collapsible-content {
            max-height: 0;
        }
        
        .animation-preview {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .anim-preview-item {
            text-align: center;
        }
        
        .anim-preview-item canvas {
            border: 1px solid #444;
            margin-bottom: 3px;
        }
        
        .anim-preview-item label {
            font-size: 10px;
        }
        
        .import-export-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        #winOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border: 2px solid #f39c12;
            text-align: center;
            z-index: 200;
        }
        
        #winOverlay h2 {
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .high-contrast {
            filter: contrast(1.5);
        }
        
        .high-contrast canvas {
            filter: drop-shadow(0 0 2px #000);
        }
        
        #fullscreenBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 150;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            border-radius: 4px;
        }
        
        #fullscreenBtn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #666;
        }
        
        /* Hide fullscreen button on mobile */
        @media (max-width: 768px) {
            #fullscreenBtn {
                display: none;
            }
        }
        
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            pointer-events: none;
            z-index: 110;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        .touch-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .touch-button.pressed {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        #dpad {
            position: absolute;
            width: 150px;
            height: 150px;
            left: 20px;
            bottom: 20px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        
        #actionButtons {
            position: absolute;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        
        .dpad-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.5);
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            cursor: pointer;
            touch-action: none;
            user-select: none;
        }
        
        .dpad-button.pressed {
            background: rgba(255, 255, 255, 0.5);
            border-color: rgba(255, 255, 255, 0.8);
        }
        
        #jumpBtn {
            position: absolute;
            width: 80px;
            height: 80px;
            right: 20px;
            bottom: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #dodgeBtn {
            position: absolute;
            width: 60px;
            height: 60px;
            right: 110px;
            bottom: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="leftPanel" class="hidden">
            <div class="tab-buttons">
                <button class="tab-button" onclick="switchTab('editor')">Editor</button>
                <button class="tab-button active" onclick="switchTab('play')">Play</button>
            </div>
            
            <div id="editorTab" class="tab-content">
                <div class="section">
                    <h3>Sprite Sheets</h3>
                    <div class="control-group">
                        <label>Sheet A (Main Cat)</label>
                        <input type="file" id="sheetA" accept="image/png">
                        <div id="sheetAThumb" class="sprite-preview"></div>
                    </div>
                    <div class="control-group">
                        <label>Sheet B (Alt Cat)</label>
                        <input type="file" id="sheetB" accept="image/png">
                        <div id="sheetBThumb" class="sprite-preview"></div>
                    </div>
                    <div class="control-group">
                        <label>Dog Sheet (NPC)</label>
                        <div id="dogThumb" class="sprite-preview"></div>
                        <canvas id="dogRunPreview" width="120" height="40" style="image-rendering: pixelated; border: 1px solid #444; margin-top: 5px;"></canvas>
                        <div style="font-size: 10px; color: #888;">Dog Run Animation</div>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Grid Editor</h3>
                    <div id="gridEditor"></div>
                </div>
                
                <div class="section">
                    <h3>Animation Preview</h3>
                    <div id="animationPreview" class="animation-preview"></div>
                </div>
                
                <div class="section">
                    <h3>Import/Export</h3>
                    <div class="import-export-buttons">
                        <button onclick="exportSettings()">Export JSON</button>
                        <button onclick="importSettings()">Import JSON</button>
                        <button onclick="resetDefaults()">Reset Defaults</button>
                    </div>
                    <textarea id="jsonData" style="width:100%; height:100px; margin-top:5px; display:none;"></textarea>
                </div>
            </div>
            
            <div id="playTab" class="tab-content active">
                <div class="section">
                    <h3>Game Controls</h3>
                    <div style="font-size: 12px; line-height: 1.5;">
                        <div>Move: A/D or ←/→</div>
                        <div>Jump: Space/W/↑</div>
                        <div>Crouch: S/↓</div>
                        <div>Sit: Q</div>
                        <div>Dodge: Shift</div>
                        <div>Restart: R</div>
                        <div>Toggle Mode: Tab</div>
                        <div>Debug: ~</div>
                        <div>Mute: M</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="collapsible" onclick="toggleCollapse(this)">Physics Tuning</div>
                    <div class="collapsible-content">
                        <div class="control-group">
                            <label>Gravity: <span id="gravityVal">500</span></label>
                            <input type="range" id="gravity" min="100" max="1000" value="500">
                        </div>
                        <div class="control-group">
                            <label>Jump Force: <span id="jumpForceVal">250</span></label>
                            <input type="range" id="jumpForce" min="100" max="400" value="250">
                        </div>
                        <div class="control-group">
                            <label>Move Speed: <span id="moveSpeedVal">150</span></label>
                            <input type="range" id="moveSpeed" min="50" max="300" value="150">
                        </div>
                        <div class="control-group">
                            <label>Friction: <span id="frictionVal">0.8</span></label>
                            <input type="range" id="friction" min="0.5" max="1" step="0.05" value="0.8">
                        </div>
                        <div class="control-group">
                            <label>Coyote Time (ms): <span id="coyoteVal">80</span></label>
                            <input type="range" id="coyoteTime" min="0" max="200" value="80">
                        </div>
                        <div class="control-group">
                            <label>Jump Buffer (ms): <span id="jumpBufferVal">100</span></label>
                            <input type="range" id="jumpBuffer" min="0" max="200" value="100">
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Accessibility</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="highContrast">
                        <label for="highContrast">High Contrast</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="reducedMotion">
                        <label for="reducedMotion">Reduced Motion</label>
                    </div>
                    <div class="control-group">
                        <label>UI Scale: <span id="scaleVal">2</span>x</label>
                        <input type="range" id="uiScale" min="1" max="4" value="2">
                    </div>
                </div>
                
                <div class="section">
                    <h3>Key Remapping</h3>
                    <button onclick="openKeyRemapping()">Configure Keys</button>
                </div>
            </div>
        </div>
        
        <div id="gameArea">
            <button id="fullscreenBtn" onclick="toggleFullscreen()">⛶</button>
            <canvas id="gameCanvas"></canvas>
            <div id="mobileControls">
                <div id="dpad">
                    <div class="dpad-button" style="top: 10px; left: 50px; width: 50px;" data-key="ArrowUp">▲</div>
                    <div class="dpad-button" style="bottom: 10px; left: 50px; width: 50px;" data-key="ArrowDown">▼</div>
                    <div class="dpad-button" style="top: 50px; left: 10px; height: 50px;" data-key="ArrowLeft">◄</div>
                    <div class="dpad-button" style="top: 50px; right: 10px; height: 50px;" data-key="ArrowRight">►</div>
                </div>
                <div id="actionButtons">
                    <button class="touch-button" id="jumpBtn" data-key=" ">Jump</button>
                    <button class="touch-button" id="dodgeBtn" data-key="Shift">Dodge</button>
                </div>
            </div>
            <div id="hud">
                <div>Score: <span id="score">0</span></div>
                <div>Lives: <span id="lives">3</span></div>
                <div>Time: <span id="time">0</span>s</div>
            </div>
            <div id="debugOverlay">
                <div>FPS: <span id="fps">0</span></div>
                <div>Pos: <span id="playerPos">0,0</span></div>
                <div>Vel: <span id="playerVel">0,0</span></div>
                <div>State: <span id="playerState">idle</span></div>
            </div>
            <div id="winOverlay">
                <h2>Level Complete!</h2>
                <div>Time: <span id="winTime">0</span>s</div>
                <div>Score: <span id="winScore">0</span></div>
                <div>Hits: <span id="winHits">0</span></div>
                <button onclick="restartLevel()">Play Again</button>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        let currentMode = 'play';
        let scale = 2;
        let highContrast = false;
        let reducedMotion = false;
        let muted = false;
        let debugMode = false;
        let isFullscreen = false;
        let isMobile = false;
        
        const sheets = {
            A: { img: null, cells: [] },
            B: { img: null, cells: [] },
            dog: { img: null, cells: [] }
        };
        
        const defaultMapping = {
            sheet: 'A',
            cells: [
                {r:1, c:1, crop:[0,0,32,32], assign:'dodge_roll', pivot:[0.5,1], flipX:false},
                {r:1, c:2, crop:[32,0,32,32], assign:'run_1', pivot:[0.5,1], flipX:false},
                {r:1, c:3, crop:[64,0,32,32], assign:'idle_sit', pivot:[0.5,1], flipX:false},
                {r:2, c:1, crop:[0,32,32,32], assign:'run_2', pivot:[0.5,1], flipX:false},
                {r:2, c:2, crop:[32,32,32,32], assign:'run_3', pivot:[0.5,1], flipX:false},
                {r:2, c:3, crop:[64,32,32,32], assign:'idle_sit_front', pivot:[0.5,1], flipX:false},
                {r:3, c:1, crop:[0,64,32,32], assign:'crouch', pivot:[0.5,1], flipX:false},
                {r:3, c:2, crop:[32,64,32,32], assign:'jump_up', pivot:[0.5,1], flipX:false},
                {r:3, c:3, crop:[64,64,32,32], assign:'fall_down', pivot:[0.5,1], flipX:false}
            ],
            fireball: null
        };
        
        let currentMapping = JSON.parse(JSON.stringify(defaultMapping));
        
        const physics = {
            gravity: 500,
            jumpForce: 250,
            moveSpeed: 150,
            friction: 0.8,
            coyoteTime: 80,
            jumpBuffer: 100
        };
        
        const keyMap = {
            left: ['ArrowLeft', 'a', 'A'],
            right: ['ArrowRight', 'd', 'D'],
            jump: [' ', 'w', 'W', 'ArrowUp'],
            crouch: ['s', 'S', 'ArrowDown'],
            sit: ['q', 'Q'],
            dodge: ['Shift'],
            restart: ['r', 'R'],
            toggleMode: ['Tab'],
            debug: ['`'],
            mute: ['m', 'M']
        };
        
        const keys = {};
        const animations = {};
        
        class Player {
            constructor() {
                this.x = 100;
                this.y = 300;
                this.vx = 0;
                this.vy = 0;
                this.width = 24;
                this.height = 28;
                this.state = 'idle_sit';
                this.facing = 1;
                this.grounded = false;
                this.lastGroundedTime = 0;
                this.jumpBufferTime = 0;
                this.dodging = false;
                this.dodgeTimer = 0;
                this.invulnerable = false;
                this.invulnTimer = 0;
                this.animFrame = 0;
                this.animTimer = 0;
                this.sitting = false;
                this.crouching = false;
                this.dead = false;
                this.prevY = 300;
                this.respawnX = 100;
                this.respawnY = 300;
                this.climbing = false;
                this.climbX = 0;
            }
            
            update(dt) {
                if (this.dead) return;
                
                const wasGrounded = this.grounded;
                this.grounded = this.checkGrounded();
                
                if (this.grounded && !wasGrounded) {
                    this.land();
                }
                
                if (this.grounded) {
                    this.lastGroundedTime = Date.now();
                }
                
                if (this.dodging) {
                    this.dodgeTimer -= dt;
                    if (this.dodgeTimer <= 0) {
                        this.dodging = false;
                        this.invulnerable = false;
                    }
                }
                
                if (this.invulnerable && !this.dodging) {
                    this.invulnTimer -= dt;
                    if (this.invulnTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                this.handleInput(dt);
                
                this.vy += physics.gravity * dt / 1000;
                
                this.prevY = this.y;
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                
                this.checkCollisions();
                
                if (!this.dodging) {
                    this.vx *= Math.pow(physics.friction, dt / 16);
                }
                
                this.updateState();
                this.updateAnimation(dt);
            }
            
            handleInput(dt) {
                // Check for cat tree climbing
                if (game) {
                    const tileX = Math.floor((this.x + this.width/2) / 16);
                    const tileY = Math.floor((this.y + this.height/2) / 16);
                    const nearTree = game.level[tileY] && (game.level[tileY][tileX] === 4 || 
                                     game.level[tileY][tileX + 1] === 4 || game.level[tileY][tileX - 1] === 4);
                    
                    if (nearTree && isKeyPressed('jump') && isKeyPressed('jump')) {
                        this.climbing = true;
                        this.climbX = Math.floor(tileX) * 16 + 8;
                        this.vx = 0;
                    }
                }
                
                if (this.climbing) {
                    this.x = this.climbX;
                    this.vx = 0;
                    
                    if (isKeyPressed('jump')) {
                        // Climb up
                        this.vy = -100;
                    } else if (isKeyPressed('crouch')) {
                        // Climb down
                        this.vy = 100;
                    } else {
                        this.vy = 0;
                    }
                    
                    if (isKeyPressed('left') || isKeyPressed('right')) {
                        // Jump off tree
                        this.climbing = false;
                        this.vy = -physics.jumpForce * 0.8;
                        this.vx = isKeyPressed('left') ? -physics.moveSpeed : physics.moveSpeed;
                    }
                    
                    return;
                }
                
                if (isKeyPressed('left')) {
                    this.vx = -physics.moveSpeed;
                    this.facing = -1;
                    this.sitting = false;
                }
                if (isKeyPressed('right')) {
                    this.vx = physics.moveSpeed;
                    this.facing = 1;
                    this.sitting = false;
                }
                
                if (isKeyPressed('jump')) {
                    this.jumpBufferTime = Date.now();
                }
                
                const canJump = this.grounded || 
                    (Date.now() - this.lastGroundedTime < physics.coyoteTime);
                const wantsJump = Date.now() - this.jumpBufferTime < physics.jumpBuffer;
                
                if (canJump && wantsJump) {
                    this.vy = -physics.jumpForce;
                    this.jumpBufferTime = 0;
                    this.sitting = false;
                    this.crouching = false;
                }
                
                if (!isKeyPressed('jump') && this.vy < 0) {
                    this.vy *= 0.5;
                }
                
                if (isKeyPressed('crouch')) {
                    this.crouching = true;
                    this.sitting = false;
                } else {
                    this.crouching = false;
                }
                
                if (isKeyPressed('sit')) {
                    this.sitting = true;
                    this.crouching = false;
                }
                
                if (isKeyPressed('dodge') && !this.dodging && this.grounded) {
                    this.dodge();
                }
            }
            
            dodge() {
                this.dodging = true;
                this.invulnerable = true;
                this.dodgeTimer = 250;
                this.vx = this.facing * physics.moveSpeed * 2;
                this.height = 16;
            }
            
            land() {
                if (!reducedMotion && game) {
                    game.createParticles(this.x, this.y + this.height, 5);
                }
            }
            
            updateState() {
                const oldState = this.state;
                
                if (this.dodging) {
                    this.state = 'dodge_roll';
                } else if (this.crouching) {
                    this.state = 'crouch';
                } else if (!this.grounded) {
                    this.state = this.vy < 0 ? 'jump_up' : 'fall_down';
                } else if (Math.abs(this.vx) > 10) {
                    this.state = 'run';
                } else if (this.sitting) {
                    this.state = 'idle_sit';
                } else {
                    this.state = 'idle_sit';
                }
                
                if (oldState !== this.state) {
                    this.animFrame = 0;
                    this.animTimer = 0;
                }
                
                if (!this.dodging && this.height === 16) {
                    this.height = 28;
                }
            }
            
            updateAnimation(dt) {
                this.animTimer += dt;
                
                const animSpeed = this.state === 'run' ? 100 : 150;
                
                if (this.animTimer >= animSpeed) {
                    this.animTimer = 0;
                    this.animFrame++;
                    
                    const frameCount = this.getFrameCount();
                    if (this.animFrame >= frameCount) {
                        this.animFrame = 0;
                    }
                }
            }
            
            getFrameCount() {
                switch(this.state) {
                    case 'run': return 3;
                    case 'dodge_roll': return 1;
                    default: return 1;
                }
            }
            
            checkGrounded() {
                // Check floor (but not for Level 3 which has pits)
                // Use typeof check to ensure game exists before accessing properties
                const isLevel3 = (typeof game !== 'undefined' && game && game.currentLevel === 3);
                
                if (!isLevel3 && this.y >= 400 - this.height) {
                    // Other levels have a solid floor at y=400
                    return true;
                }
                
                // Check if standing on a platform tile
                const tileX = Math.floor((this.x + this.width/2) / 16);
                const tileY = Math.floor((this.y + this.height + 2) / 16);
                
                // Check if the tile exists and is solid (value 1 or 3 for moving platforms)
                if (typeof game !== 'undefined' && game && game.level && game.level[tileY]) {
                    const tileValue = game.level[tileY][tileX];
                    
                    // Solid tiles (1 = platform, 3 = moving platform)
                    if (tileValue === 1 || tileValue === 3) {
                        return true;
                    }
                    
                    // IMPORTANT FIX: Explicitly handle pit tiles (value 0)
                    // Player should fall through pits, not walk over them
                    if (tileValue === 0) {
                        return false;
                    }
                }
                
                return false;
            }
            
            checkCollisions() {
                // Check for falling into pit (Level 3)
                // Increased depth from 420 to 450 so cat falls deeper into pit
                if (typeof game !== 'undefined' && game && game.currentLevel === 3 && this.y > 450) {
                    this.respawnAtCheckpoint();
                    return;
                }
                
                // Floor collision (skip for Level 3 which has pits)
                const isLevel3 = (typeof game !== 'undefined' && game && game.currentLevel === 3);
                
                if (!isLevel3 && this.y > 400 - this.height) {
                    // Other levels have a solid floor at y=400
                    this.y = 400 - this.height;
                    this.vy = 0;
                    this.grounded = true;
                }
                
                // Platform tile collisions
                if (typeof game !== 'undefined' && game && game.level) {
                    // Check multiple points along the player's bottom edge
                    let foundPlatform = false;
                    let overPit = false;
                    let centerOverPit = false;
                    
                    // First pass: Check if center of player is over a pit
                    const centerX = this.x + this.width / 2;
                    const centerTileX = Math.floor(centerX / 16);
                    const centerTileY = Math.floor((this.y + this.height) / 16);
                    const centerTile = game.level[centerTileY] && game.level[centerTileY][centerTileX];
                    
                    if (centerTile === 0) {
                        centerOverPit = true;
                    }
                    
                    // If center is over pit, don't allow landing at all
                    if (centerOverPit) {
                        overPit = true;
                        // Force falling - no platform collision when center is over pit
                        this.grounded = false;
                    } else {
                        // Only check for platform collisions if center is NOT over a pit
                        for (let xOffset = 2; xOffset < this.width - 2; xOffset += 4) {
                            const checkX = this.x + xOffset;
                            const tileX = Math.floor(checkX / 16);
                            const tileY = Math.floor((this.y + this.height) / 16);
                            
                            const tile = game.level[tileY] && game.level[tileY][tileX];
                            
                            // Check for pit tiles
                            if (tile === 0) {
                                overPit = true;
                                continue; // Keep checking other points
                            }
                            
                            if (tile === 1) {
                                // Regular platform
                                if (this.vy > 0 && this.prevY + this.height <= tileY * 16 + 4) {
                                    this.y = tileY * 16 - this.height;
                                    this.vy = 0;
                                    foundPlatform = true;
                                    // Update respawn point when on safe ground
                                    if (!this.climbing) {
                                        this.respawnX = this.x;
                                        this.respawnY = this.y;
                                    }
                                    break;
                                }
                            } else if (tile === 3) {
                                // Red couch trampoline
                                if (this.vy > 0 && this.prevY + this.height <= tileY * 16 + 4) {
                                    this.y = tileY * 16 - this.height;
                                    this.vy = -physics.jumpForce * 1.5; // Bounce higher!
                                    this.grounded = false;
                                    game.playSound('jump');
                                    // Create bounce particles
                                    if (!reducedMotion) {
                                        game.createParticles(this.x + this.width/2, this.y + this.height, 10);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Set grounded state based on what we found
                    if (foundPlatform) {
                        this.grounded = true;
                    } else if (overPit) {
                        // Explicitly NOT grounded when over a pit
                        this.grounded = false;
                    }
                    
                    // Side collisions with platforms
                    const leftTileX = Math.floor(this.x / 16);
                    const rightTileX = Math.floor((this.x + this.width) / 16);
                    const sideCenterTileY = Math.floor((this.y + this.height/2) / 16);
                    
                    // Left collision
                    if (game.level[sideCenterTileY] && game.level[sideCenterTileY][leftTileX] === 1) {
                        if (this.vx < 0) {
                            this.x = (leftTileX + 1) * 16;
                            this.vx = 0;
                        }
                    }
                    
                    // Right collision  
                    if (game.level[sideCenterTileY] && game.level[sideCenterTileY][rightTileX] === 1) {
                        if (this.vx > 0) {
                            this.x = rightTileX * 16 - this.width;
                            this.vx = 0;
                        }
                    }
                    
                    // Head collision
                    const headTileY = Math.floor(this.y / 16);
                    const headTileX = Math.floor((this.x + this.width/2) / 16);

                    if (game.level[headTileY] && game.level[headTileY][headTileX] === 1) {
                        if (this.vy < 0) {
                            this.y = (headTileY + 1) * 16;
                            this.vy = 0;

                            // Check if this is the hidden mystery block
                            if (game.mysteryBlock && !game.mysteryBlock.used &&
                                headTileX === game.mysteryBlock.x && headTileY === game.mysteryBlock.y) {

                                // Hit the mystery block!
                                game.mysteryBlock.hits++;
                                game.createParticles(headTileX * 16 + 8, headTileY * 16 + 16, 8);
                                game.playSound('jump');

                                // After 3 hits, spawn mouse and mark block as used
                                if (game.mysteryBlock.hits >= 3) {
                                    game.spawnMysteryMouse(headTileX * 16, headTileY * 16);
                                    game.mysteryBlock.used = true;
                                    // Make the block disappear (turn into empty space)
                                    game.level[headTileY][headTileX] = 0;
                                }
                            }
                        }
                    }
                    
                    // Lava collision
                    const lavaCheckY = Math.floor((this.y + this.height - 2) / 16);
                    const lavaCheckX = Math.floor((this.x + this.width/2) / 16);
                    
                    if (game.level[lavaCheckY] && game.level[lavaCheckY][lavaCheckX] === 2) {
                        this.hurt();
                    }
                }
                
                // World bounds
                if (this.x < 0) this.x = 0;
                if (this.x > 800 - this.width) this.x = 800 - this.width;
            }
            
            respawnAtCheckpoint() {
                this.x = this.respawnX;
                this.y = this.respawnY;
                this.vx = 0;
                this.vy = 0;
                this.climbing = false;
                game.createParticles(this.x + this.width/2, this.y, 20);
            }
            
            hurt() {
                if (this.invulnerable || this.dead) return;
                
                this.invulnerable = true;
                this.invulnTimer = 1000;
                
                game.lives--;
                game.hits++;
                
                if (game.lives <= 0) {
                    this.die();
                }
            }
            
            die() {
                this.dead = true;
                this.state = 'dead';
                setTimeout(() => game.restart(), 2000);
            }
            
            draw(ctx) {
                ctx.save();
                
                if (this.invulnerable) {
                    ctx.globalAlpha = Math.sin(Date.now() * 0.01) > 0 ? 1 : 0.5;
                }
                
                const sprite = this.getSprite();
                if (sprite && sprite.img) {
                    ctx.translate(this.x + this.width/2, this.y + this.height);
                    
                    if (this.facing === -1) {
                        ctx.scale(-1, 1);
                    }
                    
                    const crop = sprite.crop;
                    ctx.drawImage(
                        sprite.img,
                        crop[0], crop[1], crop[2], crop[3],
                        -this.width/2, -this.height, this.width, this.height
                    );
                } else {
                    ctx.fillStyle = this.invulnerable ? '#ff0000' : '#ffffff';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                
                ctx.restore();
            }
            
            getSprite() {
                const mapping = this.getMappingForState();
                if (!mapping) return null;
                
                const sheet = sheets[currentMapping.sheet];
                if (!sheet || !sheet.img) return null;
                
                return {
                    img: sheet.img,
                    crop: mapping.crop,
                    pivot: mapping.pivot
                };
            }
            
            getMappingForState() {
                let searchState = this.state;
                
                if (this.state === 'run') {
                    const frameMap = ['run_1', 'run_2', 'run_3'];
                    searchState = frameMap[this.animFrame % 3];
                }
                
                return currentMapping.cells.find(c => c.assign === searchState);
            }
        }
        
        class Particle {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 10;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = -Math.random() * 100 - 50;
                this.life = 500;
                this.maxLife = 500;
            }
            
            update(dt) {
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                this.vy += 300 * dt / 1000;
                this.life -= dt;
            }
            
            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life / this.maxLife})`;
                ctx.fillRect(this.x, this.y, 2, 2);
            }
        }
        
        class Fireball {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = 12;
                this.height = 12;
            }
            
            update(dt) {
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                this.vy += 200 * dt / 1000;
                
                // Check collision with platform tiles
                if (game) {
                    const tileX = Math.floor((this.x + this.width/2) / 16);
                    const tileY = Math.floor((this.y + this.height/2) / 16);
                    
                    if (game.level[tileY] && game.level[tileY][tileX] === 1) {
                        // Fireball hits platform, reset it
                        this.reset();
                        return;
                    }
                }
                
                // Reset if falls off screen
                if (this.y > 450) {
                    this.reset();
                }
            }
            
            reset() {
                this.y = -50;
                this.x = 100 + Math.random() * 600;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = 0;
            }
            
            draw(ctx) {
                if (currentMapping.fireball) {
                    const sheet = sheets[currentMapping.fireball.sheet];
                    if (sheet && sheet.img) {
                        const crop = currentMapping.fireball.crop;
                        ctx.drawImage(
                            sheet.img,
                            crop[0], crop[1], crop[2], crop[3],
                            this.x, this.y, this.width, this.height
                        );
                        return;
                    }
                }
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(this.x + 6, this.y + 6, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(this.x + 6, this.y + 6, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            checkCollision(player) {
                if (player.invulnerable) return false;
                
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
        }
        
        class Dog {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 28;
                this.height = 24;
                this.grounded = false;
                this.facing = 1;
                this.state = 'idle';
                this.animFrame = 0;
                this.animTimer = 0;
                this.spawnTimer = 0;
                this.active = false;
                this.chasing = false;
                this.sightRange = 150;
                this.moveSpeed = 100;
                this.jumpCooldown = 0;
                this.bounceCount = 0;
                this.runningAway = false;
            }
            
            spawn() {
                // Random spawn position
                this.x = Math.random() > 0.5 ? -50 : 850;
                this.y = 300;
                this.active = true;
                this.spawnTimer = 0;
                this.facing = this.x < 400 ? 1 : -1;
            }
            
            update(dt) {
                if (!this.active) {
                    this.spawnTimer += dt;
                    // Spawn every 15-25 seconds
                    if (this.spawnTimer > 15000 + Math.random() * 10000) {
                        this.spawn();
                    }
                    return;
                }
                
                // If running away (level 4), just keep moving right
                if (this.runningAway) {
                    this.vx = 500;
                    this.x += this.vx * dt / 1000;
                    this.state = 'run';
                    this.animTimer += dt;
                    if (this.animTimer > 150) {
                        this.animTimer = 0;
                        this.animFrame = (this.animFrame + 1) % 3;
                    }
                    
                    // Check if dog has left the screen
                    if (this.x > 850) {
                        // Move to next level
                        if (game && game.currentLevel === 4) {
                            game.currentLevel = 5;
                            game.level = game.createLevel();
                            game.initLevel();
                            game.player.x = 100;
                            game.player.y = 300;
                        }
                    }
                    return;
                }
                
                this.jumpCooldown -= dt;
                
                // Check if can see player
                const player = game.player;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Line of sight check - but in level 4, dog doesn't chase
                if (game && game.currentLevel === 4) {
                    this.chasing = false;
                    this.active = true; // Keep dog active
                } else if (dist < this.sightRange && Math.sign(dx) === this.facing) {
                    this.chasing = true;
                } else if (dist > this.sightRange * 1.5) {
                    this.chasing = false;
                }
                
                // Movement AI
                if (this.chasing) {
                    // Chase player
                    this.facing = Math.sign(dx);
                    this.vx = this.facing * this.moveSpeed;
                    
                    // Jump if player is above and grounded
                    if (dy < -20 && this.grounded && this.jumpCooldown <= 0) {
                        this.vy = -200;
                        this.jumpCooldown = 1000;
                    }
                } else {
                    // Wander and look for treats
                    this.vx = this.facing * this.moveSpeed * 0.5;
                    
                    // Random direction change
                    if (Math.random() < 0.01) {
                        this.facing *= -1;
                    }
                }
                
                // Physics
                this.vy += 500 * dt / 1000;
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                
                // Ground collision
                this.grounded = false;
                if (this.y > 400 - this.height) {
                    this.y = 400 - this.height;
                    this.vy = 0;
                    this.grounded = true;
                }
                
                // Platform collisions
                if (game) {
                    const tileX = Math.floor((this.x + this.width/2) / 16);
                    const tileY = Math.floor((this.y + this.height) / 16);
                    
                    if (game.level[tileY] && (game.level[tileY][tileX] === 1 || game.level[tileY][tileX] === 3)) {
                        if (this.vy > 0) {
                            this.y = tileY * 16 - this.height;
                            this.vy = 0;
                            this.grounded = true;
                            
                            // Bounce on couch
                            if (game.level[tileY][tileX] === 3) {
                                this.vy = -300;
                            }
                        }
                    }
                }
                
                // Despawn if too far off screen
                if (this.x < -200 || this.x > 1000) {
                    this.active = false;
                    this.spawnTimer = 10000; // Wait before next spawn
                }
                
                // Update animation state
                if (Math.abs(this.vx) > 10) {
                    this.state = 'run';
                } else {
                    this.state = 'idle';
                }
                
                // Debug: Log sprite status once
                if (!this.loggedSpriteStatus && sheets.dog) {
                    console.log('Dog sprite status:', sheets.dog.img ? 'Loaded' : 'Not loaded');
                    this.loggedSpriteStatus = true;
                }
                
                this.animTimer += dt;
                if (this.animTimer > 150) {
                    this.animTimer = 0;
                    this.animFrame = (this.animFrame + 1) % 3;
                }
                
                // Eat nearby treats
                this.eatTreats();
                
                // Check collision with player
                this.checkPlayerCollision();
            }
            
            eatTreats() {
                if (!game) return;
                
                game.fishTreats.forEach(treat => {
                    if (!treat.collected) {
                        const dx = Math.abs(this.x + this.width/2 - treat.x - 6);
                        const dy = Math.abs(this.y + this.height/2 - treat.y - 5);
                        
                        if (dx < 20 && dy < 20) {
                            treat.collected = true;
                            // Dog gets excited animation
                            this.animTimer = 0;
                        }
                    }
                });
            }
            
            checkPlayerCollision() {
                if (!game || this.runningAway) return;
                
                const player = game.player;
                const dx = Math.abs(this.x + this.width/2 - player.x - player.width/2);
                const dy = Math.abs(this.y + this.height/2 - player.y - player.height/2);
                
                if (dx < (this.width + player.width) / 2 && dy < (this.height + player.height) / 2) {
                    // Check if player is above dog (bouncing on it) in level 4
                    if (game.currentLevel === 4 && player.y < this.y && player.vy > 0) {
                        // Player bounces on dog
                        player.vy = -400; // Strong upward bounce
                        this.bounceCount++;
                        
                        // Visual feedback
                        this.animTimer = 0;
                        
                        if (this.bounceCount >= 3) {
                            // Dog runs away after 3 bounces
                            this.runningAway = true;
                            this.vx = 500;
                            this.state = 'run';
                            this.facing = 1;
                        }
                        player.climbing = false;
                        return;
                    }
                    
                    // Normal collision - bounce player away
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    player.vx = Math.cos(angle) * 300;
                    player.vy = Math.sin(angle) * 200 - 100;
                    player.climbing = false;
                    
                    // Create particles
                    if (!reducedMotion) {
                        game.createParticles(player.x + player.width/2, player.y + player.height/2, 10);
                    }
                    
                    game.playSound('hurt');
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height);
                
                if (this.facing === -1) {
                    ctx.scale(-1, 1);
                }
                
                // Draw dog sprite (fallback to rectangle if no sprite)
                const dogSheet = sheets.dog;
                if (dogSheet && dogSheet.img) {
                    // Use sprite from sheet - bonbon_dog_3x3.png layout
                    const spriteMap = {
                        'idle': {r: 2, c: 2}, // Middle dog sitting
                        'run': [{r: 2, c: 1}, {r: 2, c: 2}, {r: 2, c: 3}] // Row 2 for run animation
                    };
                    
                    let sprite = spriteMap[this.state];
                    if (Array.isArray(sprite)) {
                        sprite = sprite[this.animFrame % sprite.length];
                    }
                    
                    const cellSize = Math.floor(dogSheet.img.width / 3);
                    const sx = (sprite.c - 1) * cellSize;
                    const sy = (sprite.r - 1) * cellSize;
                    
                    // Draw with proper scaling
                    ctx.drawImage(
                        dogSheet.img,
                        sx, sy, cellSize, cellSize,
                        -this.width/2, -this.height, this.width, this.height
                    );
                } else {
                    // Fallback dog drawing
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-this.width/2, -this.height, this.width, this.height);
                    
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(-8, -this.height + 5, 3, 3);
                    ctx.fillRect(5, -this.height + 5, 3, 3);
                    
                    // Tail
                    ctx.fillStyle = '#8B4513';
                    if (this.chasing) {
                        // Wagging tail when chasing
                        const wag = Math.sin(Date.now() * 0.01) * 10;
                        ctx.fillRect(this.width/2 - 5, -this.height/2 + wag, 10, 4);
                    } else {
                        ctx.fillRect(this.width/2 - 5, -this.height/2, 10, 4);
                    }
                }
                
                ctx.restore();
                
                // Draw "!" when chasing
                if (this.chasing) {
                    ctx.fillStyle = '#FF0000';
                    ctx.font = '16px monospace';
                    ctx.fillText('!', this.x + this.width/2 - 4, this.y - 10);
                }
            }
        }
        
        class Mouse {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = 0;
                this.width = 8;
                this.height = 6;
                this.grounded = false;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.moveTimer = 0;
                this.caught = false;
                this.jumpCooldown = 0;
            }
            
            update(dt) {
                if (this.caught) return;
                
                this.jumpCooldown -= dt;
                this.moveTimer += dt;
                
                // Change direction randomly
                if (this.moveTimer > 1000 + Math.random() * 2000) {
                    this.moveTimer = 0;
                    this.direction = Math.random() > 0.5 ? 1 : -1;
                    
                    // Sometimes jump
                    if (Math.random() > 0.7 && this.grounded && this.jumpCooldown <= 0) {
                        this.vy = -150;
                        this.jumpCooldown = 1000;
                    }
                }
                
                // Move
                this.vx = this.direction * 50;
                
                // Physics
                this.vy += 500 * dt / 1000;
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                
                // Ground collision
                this.grounded = false;
                if (this.y > 400 - this.height) {
                    this.y = 400 - this.height;
                    this.vy = 0;
                    this.grounded = true;
                }
                
                // Platform collisions (for Level 1 mystery mouse and Level 2 mice)
                if (game && (game.currentLevel === 1 || game.currentLevel === 2)) {
                    const tileX = Math.floor((this.x + this.width/2) / 16);
                    const tileY = Math.floor((this.y + this.height) / 16);

                    if (game.level[tileY] && game.level[tileY][tileX] === 1) {
                        if (this.vy > 0) {
                            this.y = tileY * 16 - this.height;
                            this.vy = 0;
                            this.grounded = true;
                        }
                    }
                }
                
                // World bounds
                if (this.x < 0 || this.x > 800 - this.width) {
                    this.direction *= -1;
                    this.x = Math.max(0, Math.min(this.x, 800 - this.width));
                }
            }
            
            draw(ctx) {
                if (this.caught) return;
                
                // Draw simple pixel mouse
                ctx.fillStyle = '#808080';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Tail
                ctx.fillRect(this.x - 4, this.y + 2, 4, 2);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 1, this.y + 1, 1, 1);
                ctx.fillRect(this.x + 3, this.y + 1, 1, 1);
                
                // Ears
                ctx.fillStyle = '#808080';
                ctx.fillRect(this.x + 1, this.y - 2, 2, 2);
                ctx.fillRect(this.x + 5, this.y - 2, 2, 2);
            }
            
            checkCaught(player) {
                if (this.caught) return false;
                
                // Only catch if player is moving
                if (Math.abs(player.vx) < 10) return false;
                
                const dx = Math.abs(this.x - player.x);
                const dy = Math.abs(this.y - player.y);
                
                if (dx < player.width && dy < player.height) {
                    this.caught = true;
                    return true;
                }
                return false;
            }
            
            checkCollisionWithStaticCat(player) {
                if (this.caught) return false;
                
                // Only collide if cat is stationary
                if (Math.abs(player.vx) > 10) return false;
                
                const dx = Math.abs(this.x - player.x);
                const dy = Math.abs(this.y - player.y);
                
                return dx < player.width && dy < player.height;
            }
        }
        
        class Game {
            constructor() {
                this.player = new Player();
                this.particles = [];
                this.fireballs = [];
                this.mice = [];
                this.dog = null;
                this.camera = { x: 0, y: 0 };
                this.score = 0;
                this.lives = 3;
                this.hits = 0;
                this.speedBoost = 1;
                this.speedBoostTimer = 0;
                this.treatsCollected = 0;
                this.startTime = Date.now();
                this.lastTime = Date.now();
                this.fps = 0;
                this.frameCount = 0;
                this.fpsTimer = 0;
                this.currentLevel = 1;
                this.level = this.createLevel();
                this.fishTreats = this.createFishTreats();
                this.goalReached = false;
                this.mysteryBlock = { x: 12, y: 20, hits: 0, used: false }; // Hidden in platform above couch

                this.initLevel();
            }
            
            initLevel() {
                if (this.currentLevel === 1) {
                    this.initFireballs();
                    this.dog = null;
                } else if (this.currentLevel === 2) {
                    this.initMice();
                    this.fireballs = [];
                    this.dog = null;
                } else if (this.currentLevel === 3) {
                    this.fireballs = [];
                    this.mice = [];
                    this.dog = null;
                } else if (this.currentLevel === 4) {
                    // Level 4 - Dog bounce level
                    this.fireballs = [];
                    this.mice = [];
                    this.fishTreats = [];
                    this.dog = new Dog(400, 350);
                    this.dog.active = true; // Dog is immediately active
                    this.dog.chasing = false; // Dog just stands there
                } else if (this.currentLevel === 5) {
                    // Level 5 - Victory feast!
                    this.fireballs = [];
                    this.mice = [];
                    this.fishTreats = [];
                    this.dog = null;
                    this.waterBowl = { x: 350, y: 370, width: 40, height: 20 };
                    this.foodPlate = { x: 450, y: 370, width: 40, height: 20 };
                    this.catHasEaten = false;
                    this.catHasDrunk = false;
                }
            }
            
            initFireballs() {
                this.fireballs = [];
                for (let i = 0; i < 3; i++) {
                    this.fireballs.push(new Fireball(
                        200 + i * 200,
                        100,
                        (Math.random() - 0.5) * 100,
                        0
                    ));
                }
            }
            
            initMice() {
                this.mice = [];
                // Create 8 mice at various positions
                const mousePositions = [
                    {x: 200, y: 350},
                    {x: 350, y: 350},
                    {x: 500, y: 350},
                    {x: 180, y: 300},
                    {x: 320, y: 280},
                    {x: 450, y: 250},
                    {x: 600, y: 350},
                    {x: 700, y: 350}
                ];
                
                mousePositions.forEach(pos => {
                    this.mice.push(new Mouse(pos.x, pos.y));
                });
            }
            
            createLevel() {
                const level = [];
                
                if (this.currentLevel === 1) {
                    // Level 1 - Platformer with fireballs
                    for (let y = 0; y < 30; y++) {
                        level[y] = [];
                        for (let x = 0; x < 50; x++) {
                            if (y === 25) {
                                // Main ground
                                level[y][x] = 1;
                            } else if (y === 20 && x >= 10 && x <= 14) {
                                // Platform 1
                                level[y][x] = 1;
                            } else if (y === 18 && x >= 20 && x <= 24) {
                                // Platform 2
                                level[y][x] = 1;
                            } else if (y === 22 && x >= 30 && x <= 34) {
                                // Platform 3
                                level[y][x] = 1;
                            } else if (y === 15 && x >= 25 && x <= 29) {
                                // Higher platform
                                level[y][x] = 1;
                            } else if (y === 16 && x >= 40 && x <= 44) {
                                // Another platform
                                level[y][x] = 1;
                            } else if (y > 26 && x >= 15 && x <= 19) {
                                // Lava pit
                                level[y][x] = 2;
                            } else if ((y === 24 || y === 25) && (x === 12 || x === 13)) {
                                // Red couch trampoline (2x2 tiles at ground level)
                                level[y][x] = 3;
                            } else {
                                level[y][x] = 0;
                            }
                        }
                    }
                } else if (this.currentLevel === 2) {
                    // Level 2 - Mouse catching arena
                    for (let y = 0; y < 30; y++) {
                        level[y] = [];
                        for (let x = 0; x < 50; x++) {
                            if (y === 25) {
                                // Main ground
                                level[y][x] = 1;
                            } else if (y === 22 && x >= 8 && x <= 12) {
                                // Small platform left
                                level[y][x] = 1;
                            } else if (y === 20 && x >= 18 && x <= 22) {
                                // Mid platform
                                level[y][x] = 1;
                            } else if (y === 22 && x >= 28 && x <= 32) {
                                // Small platform right
                                level[y][x] = 1;
                            } else if (y === 18 && x >= 38 && x <= 42) {
                                // High platform
                                level[y][x] = 1;
                            } else if ((y === 24 || y === 25) && (x === 15 || x === 16)) {
                                // Red couch (2x2 tiles at ground level)
                                level[y][x] = 3;
                            } else {
                                level[y][x] = 0;
                            }
                        }
                    }
                } else if (this.currentLevel === 3) {
                    // Level 3 - Challenge arena with pits
                    for (let y = 0; y < 30; y++) {
                        level[y] = [];
                        for (let x = 0; x < 50; x++) {
                            if (y === 25) {
                                // Ground with gaps (pits)
                                if (x < 8 || (x >= 12 && x <= 18) || (x >= 23 && x <= 30) || x >= 35) {
                                    level[y][x] = 1;
                                } else {
                                    level[y][x] = 0; // Pits
                                }
                            } else if (y === 22 && x >= 5 && x <= 7) {
                                // Small safe platform before first pit
                                level[y][x] = 1;
                            } else if (y === 20 && x >= 9 && x <= 11) {
                                // Floating platform over first pit
                                level[y][x] = 1;
                            } else if (y === 19 && x >= 20 && x <= 22) {
                                // Floating platform over second pit
                                level[y][x] = 1;
                            } else if (y === 17 && x >= 26 && x <= 28) {
                                // Higher platform
                                level[y][x] = 1;
                            } else if (y === 21 && x >= 32 && x <= 34) {
                                // Platform over third pit
                                level[y][x] = 1;
                            } else if (y === 15 && x >= 15 && x <= 17) {
                                // High challenge platform
                                level[y][x] = 1;
                            } else if ((y === 24 || y === 25) && (x === 25 || x === 26)) {
                                // Red couch for big jump (2x2 tiles at ground level)
                                level[y][x] = 3;
                            } else if ((y === 24 || y === 25) && (x === 6 || x === 7)) {
                                // Another couch (2x2 tiles at ground level)
                                level[y][x] = 3;
                            } else {
                                level[y][x] = 0;
                            }
                        }
                    }
                    
                    // Add cat tree at x=40
                    this.addCatTree(level, 40, 25, 5);
                } else if (this.currentLevel === 4) {
                    // Level 4 - Simple grass platform level
                    for (let y = 0; y < 30; y++) {
                        level[y] = [];
                        for (let x = 0; x < 50; x++) {
                            if (y === 25) {
                                // Solid grass ground
                                level[y][x] = 4; // Grass tile (we'll render it green)
                            } else if (y > 25) {
                                // Underground dirt
                                level[y][x] = 1;
                            } else {
                                level[y][x] = 0;
                            }
                        }
                    }
                } else if (this.currentLevel === 5) {
                    // Level 5 - Cozy room with food and water
                    for (let y = 0; y < 30; y++) {
                        level[y] = [];
                        for (let x = 0; x < 50; x++) {
                            if (y === 25) {
                                // Floor
                                level[y][x] = 2; // Wood floor tile
                            } else if (y > 25) {
                                level[y][x] = 2;
                            } else if (x === 0 || x === 49) {
                                // Walls
                                level[y][x] = 3;
                            } else if (y === 0) {
                                // Ceiling
                                level[y][x] = 3;
                            } else {
                                level[y][x] = 0;
                            }
                        }
                    }
                }
                
                return level;
            }
            
            addCatTree(level, x, groundY, height) {
                // Cat tree trunk (climbable)
                for (let y = groundY - height; y < groundY; y++) {
                    if (level[y]) {
                        level[y][x] = 4; // Cat tree tile
                        level[y][x + 1] = 4;
                    }
                }
                
                // Platform on top
                const topY = groundY - height - 1;
                if (level[topY]) {
                    for (let px = x - 1; px <= x + 2; px++) {
                        if (px >= 0 && px < 50) {
                            level[topY][px] = 1;
                        }
                    }
                }
            }
            
            createFishTreats() {
                return [
                    {x: 240, y: 280, collected: false},
                    {x: 360, y: 250, collected: false},
                    {x: 520, y: 330, collected: false},
                    {x: 600, y: 200, collected: false}
                ];
            }
            
            update(dt) {
                // Update speed boost timer
                if (this.speedBoostTimer > 0) {
                    this.speedBoostTimer -= dt;
                    if (this.speedBoostTimer <= 0) {
                        this.speedBoost = 1;
                    }
                }
                
                // Apply speed boost to physics
                const originalSpeed = physics.moveSpeed;
                physics.moveSpeed = originalSpeed * this.speedBoost;
                
                this.player.update(dt);
                
                // Restore original speed
                physics.moveSpeed = originalSpeed;
                
                this.particles = this.particles.filter(p => {
                    p.update(dt);
                    return p.life > 0;
                });
                
                // Level 1 - Fireballs and mystery mouse
                if (this.currentLevel === 1) {
                    this.fireballs.forEach(f => {
                        f.update(dt);
                        if (f.checkCollision(this.player)) {
                            this.player.hurt();
                        }
                    });

                    // Update and check mystery mouse if spawned
                    this.mice.forEach(mouse => {
                        mouse.update(dt);

                        // Check if caught
                        if (mouse.checkCaught(this.player)) {
                            this.score += 500; // Bonus points for mystery mouse!
                            this.playSound('collect');
                        }
                    });

                    // Check goal
                    if (this.player.x > 750 && !this.goalReached) {
                        this.goalReached = true;
                        this.nextLevel();
                    }
                }
                
                // Level 2 - Mice
                if (this.currentLevel === 2) {
                    this.mice.forEach(mouse => {
                        mouse.update(dt);
                        
                        // Check if caught
                        if (mouse.checkCaught(this.player)) {
                            this.score += 200;
                            this.playSound('collect');
                            
                            // Check win condition
                            const uncaughtMice = this.mice.filter(m => !m.caught).length;
                            if (uncaughtMice === 0) {
                                this.nextLevel();
                            }
                        }
                        
                        // Check collision with static cat
                        if (mouse.checkCollisionWithStaticCat(this.player)) {
                            if (this.treatsCollected > 0) {
                                // Eject treats
                                this.ejectTreats();
                                mouse.direction *= -1; // Bounce mouse away
                            }
                        }
                    });
                }
                
                // Level 3 - Challenge with pits
                if (this.currentLevel === 3) {
                    // Check goal (bed)
                    if (this.player.x > 740 && !this.goalReached) {
                        this.goalReached = true;
                        this.nextLevel();
                    }
                }
                
                // Level 4 - Dog bounce
                if (this.currentLevel === 4) {
                    if (this.dog) {
                        this.dog.update(dt);
                    }
                } else if (this.currentLevel === 5) {
                    // Check if cat is near water bowl
                    if (!this.catHasDrunk && 
                        Math.abs(this.player.x - this.waterBowl.x) < 40 &&
                        Math.abs(this.player.y - this.waterBowl.y) < 40) {
                        this.catHasDrunk = true;
                    }
                    
                    // Check if cat is near food plate
                    if (!this.catHasEaten && 
                        Math.abs(this.player.x - this.foodPlate.x) < 40 &&
                        Math.abs(this.player.y - this.foodPlate.y) < 40) {
                        this.catHasEaten = true;
                    }
                    
                    // Win condition: cat has eaten and drunk
                    if (this.catHasEaten && this.catHasDrunk && !this.goalReached) {
                        this.goalReached = true;
                        this.showWinScreen();
                    }
                }
                
                // Collect treats
                this.fishTreats.forEach(fish => {
                    if (!fish.collected) {
                        const dx = Math.abs(this.player.x - fish.x);
                        const dy = Math.abs(this.player.y - fish.y);
                        if (dx < 20 && dy < 20) {
                            fish.collected = true;
                            this.score += 100;
                            this.treatsCollected++;
                            
                            // Add speed boost
                            this.speedBoost = Math.min(2, this.speedBoost + 0.15);
                            this.speedBoostTimer = 5000; // 5 seconds
                            
                            this.playSound('collect');
                        }
                    }
                });
                
                this.updateCamera();
                
                this.frameCount++;
                this.fpsTimer += dt;
                if (this.fpsTimer >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.fpsTimer = 0;
                }
            }
            
            ejectTreats() {
                const treatCount = Math.min(3, this.treatsCollected);
                this.treatsCollected = Math.max(0, this.treatsCollected - treatCount);
                
                // Create flying treats
                for (let i = 0; i < treatCount; i++) {
                    const angle = (Math.PI * 2 / treatCount) * i;
                    const speed = 150;
                    this.fishTreats.push({
                        x: this.player.x + this.player.width/2,
                        y: this.player.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 100,
                        collected: false,
                        flying: true
                    });
                }
                
                // Reduce speed boost
                this.speedBoost = Math.max(1, this.speedBoost - treatCount * 0.15);
                this.playSound('hurt');
            }
            
            nextLevel() {
                this.currentLevel++;
                if (this.currentLevel > 4) {
                    // Game complete!
                    this.showWinScreen();
                    return;
                }
                
                this.player.x = 100;
                this.player.y = 300;
                this.player.respawnX = 100;
                this.player.respawnY = 300;
                this.player.climbing = false;
                this.level = this.createLevel();
                this.fishTreats = this.createFishTreats();
                this.initLevel();
                this.goalReached = false;
            }
            
            updateCamera() {
                const targetX = this.player.x - canvas.width / 2 / scale;
                const targetY = this.player.y - canvas.height / 2 / scale;
                
                this.camera.x += (targetX - this.camera.x) * 0.1;
                this.camera.y += (targetY - this.camera.y) * 0.1;
                
                this.camera.x = Math.max(0, Math.min(this.camera.x, 800 - canvas.width / scale));
                this.camera.y = Math.max(0, Math.min(this.camera.y, 480 - canvas.height / scale));
            }
            
            draw() {
                // Different background for level 2
                ctx.fillStyle = this.currentLevel === 2 ? '#4A5F7A' : '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.save();
                // Don't scale here since canvas is already sized correctly
                ctx.translate(-this.camera.x, -this.camera.y);
                
                this.drawParallax();
                this.drawLevel();
                
                // Draw treats as goldfish crackers
                this.fishTreats.forEach(fish => {
                    if (!fish.collected) {
                        if (fish.flying) {
                            // Update flying treat physics
                            fish.x += fish.vx * 0.016;
                            fish.y += fish.vy * 0.016;
                            fish.vy += 500 * 0.016;
                            
                            // Stop when hits ground
                            if (fish.y > 390) {
                                fish.y = 390;
                                fish.flying = false;
                                fish.vx = 0;
                                fish.vy = 0;
                            }
                        }
                        
                        // Draw goldfish cracker shape
                        ctx.save();
                        ctx.translate(fish.x + 6, fish.y + 5);
                        ctx.rotate(Math.sin(Date.now() * 0.002 + fish.x) * 0.1);
                        
                        // Body (oval)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Tail
                        ctx.beginPath();
                        ctx.moveTo(4, 0);
                        ctx.lineTo(8, -2);
                        ctx.lineTo(8, 2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Eye
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-3, -1, 2, 2);
                        
                        // Smile
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.arc(-1, 0, 2, 0.2, Math.PI - 0.2, false);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                
                // Goal bed for levels 1, 3, and 4
                if (this.currentLevel === 1 || this.currentLevel === 3 || this.currentLevel === 4) {
                    this.drawBed(750, 350);
                }
                
                // Draw mice for level 1 (mystery mouse) and level 2
                if (this.currentLevel === 1 || this.currentLevel === 2) {
                    this.mice.forEach(mouse => mouse.draw(ctx));

                    // Draw mouse counter for level 2 only
                    if (this.currentLevel === 2) {
                        const uncaughtMice = this.mice.filter(m => !m.caught).length;
                        ctx.fillStyle = '#FFF';
                        ctx.font = '16px monospace';
                        ctx.fillText(`Mice: ${uncaughtMice}/${this.mice.length}`, 10, 30);
                    }
                }
                
                // Draw speed boost indicator
                if (this.speedBoost > 1) {
                    ctx.fillStyle = `rgba(255, 255, 0, ${0.3 + Math.sin(Date.now() * 0.01) * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(this.player.x + this.player.width/2, this.player.y + this.player.height/2, 
                            20 + Math.sin(Date.now() * 0.01) * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                this.particles.forEach(p => p.draw(ctx));
                this.fireballs.forEach(f => f.draw(ctx));
                
                // Draw dog for level 4
                if (this.currentLevel === 4 && this.dog) {
                    this.dog.draw(ctx);
                }
                
                this.player.draw(ctx);
                
                ctx.restore();
            }
            
            drawParallax() {
                ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
                for (let i = 0; i < 5; i++) {
                    const x = (i * 200 - this.camera.x * 0.3) % 1000;
                    const y = 100 + Math.sin(i) * 20;
                    ctx.fillRect(x, y, 150, 80);
                }
                
                ctx.fillStyle = 'rgba(80, 120, 80, 0.4)';
                for (let i = 0; i < 8; i++) {
                    const x = (i * 150 - this.camera.x * 0.5) % 1000;
                    const y = 200 + Math.sin(i * 2) * 15;
                    ctx.fillRect(x, y, 100, 100);
                }
            }
            
            drawLevel() {
                for (let y = 0; y < this.level.length; y++) {
                    for (let x = 0; x < this.level[y].length; x++) {
                        const tile = this.level[y][x];
                        if (tile === 1) {
                            // Regular platform
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(x * 16, y * 16, 16, 16);
                            ctx.fillStyle = '#654321';
                            ctx.fillRect(x * 16 + 2, y * 16 + 2, 12, 12);
                        } else if (tile === 2) {
                            // Wood floor (for level 5)
                            ctx.fillStyle = '#8B6F47';
                            ctx.fillRect(x * 16, y * 16, 16, 16);
                            // Wood grain
                            ctx.fillStyle = '#6B5637';
                            ctx.fillRect(x * 16, y * 16 + 4, 16, 1);
                            ctx.fillRect(x * 16, y * 16 + 11, 16, 1);
                        } else if (tile === 3) {
                            // Wall/Couch depending on level
                            if (this.currentLevel === 5) {
                                // Wall tile
                                ctx.fillStyle = '#D2691E';
                                ctx.fillRect(x * 16, y * 16, 16, 16);
                                ctx.fillStyle = '#A0522D';
                                ctx.fillRect(x * 16 + 1, y * 16 + 1, 14, 14);
                            } else {
                                // Red couch trampoline
                                this.drawCouch(x * 16, y * 16);
                            }
                        } else if (tile === 4) {
                            // Grass tile (for level 4)
                            // Draw dirt underneath
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(x * 16, y * 16, 16, 16);
                            // Draw grass on top
                            ctx.fillStyle = '#228B22';
                            ctx.fillRect(x * 16, y * 16, 16, 6);
                            // Grass blades
                            ctx.fillStyle = '#32CD32';
                            for (let i = 0; i < 16; i += 3) {
                                ctx.fillRect(x * 16 + i, y * 16, 2, 4);
                            }
                        }
                    }
                }
                
                // Draw water bowl and food plate in level 5
                if (this.currentLevel === 5) {
                    // Draw water bowl
                    ctx.fillStyle = '#4169E1';
                    ctx.fillRect(this.waterBowl.x, this.waterBowl.y, this.waterBowl.width, this.waterBowl.height);
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(this.waterBowl.x + 4, this.waterBowl.y + 2, this.waterBowl.width - 8, this.waterBowl.height - 6);
                    if (this.catHasDrunk) {
                        ctx.fillStyle = '#32CD32';
                        ctx.fillText('✓', this.waterBowl.x + 15, this.waterBowl.y - 5);
                    }
                    
                    // Draw food plate
                    ctx.fillStyle = '#CD853F';
                    ctx.fillRect(this.foodPlate.x, this.foodPlate.y, this.foodPlate.width, this.foodPlate.height);
                    if (!this.catHasEaten) {
                        // Draw wet food
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(this.foodPlate.x + 8, this.foodPlate.y - 5, 24, 15);
                        ctx.fillStyle = '#D2691E';
                        ctx.fillRect(this.foodPlate.x + 10, this.foodPlate.y - 3, 20, 11);
                    } else {
                        ctx.fillStyle = '#32CD32';
                        ctx.fillText('✓', this.foodPlate.x + 15, this.foodPlate.y - 5);
                    }
                }
            }
            
            drawCouch(x, y) {
                // Couch base (2x size)
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(x, y + 8, 32, 24);

                // Cushion (2x size)
                ctx.fillStyle = '#DC143C';
                ctx.fillRect(x + 2, y + 4, 28, 20);

                // Cushion detail (2x size)
                ctx.fillStyle = '#FF1493';
                ctx.fillRect(x + 6, y + 8, 20, 12);

                // Legs (2x size)
                ctx.fillStyle = '#4B2F20';
                ctx.fillRect(x + 4, y + 28, 4, 4);
                ctx.fillRect(x + 24, y + 28, 4, 4);
            }
            
            drawCatTree(x, y) {
                // Tree trunk texture
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(x, y, 16, 16);
                
                // Carpet texture
                ctx.fillStyle = '#D2B48C';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(x + 2, y + i * 4, 12, 2);
                }
                
                // Scratching post lines
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 4, y);
                ctx.lineTo(x + 4, y + 16);
                ctx.moveTo(x + 12, y);
                ctx.lineTo(x + 12, y + 16);
                ctx.stroke();
            }
            
            drawBed(x, y) {
                // Bed base
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x, y + 20, 40, 10);
                
                // Mattress
                ctx.fillStyle = '#F5DEB3';
                ctx.fillRect(x + 2, y + 15, 36, 12);
                
                // Pillow
                ctx.fillStyle = '#FFB6C1';
                ctx.fillRect(x + 5, y + 12, 12, 8);
                ctx.fillRect(x + 23, y + 12, 12, 8);
                
                // Blanket
                ctx.fillStyle = '#DEB887';
                ctx.fillRect(x + 3, y + 18, 34, 8);
                
                // Z's for sleeping (animated)
                if (Date.now() % 2000 < 1000) {
                    ctx.fillStyle = '#4169E1';
                    ctx.font = '12px monospace';
                    ctx.fillText('Z', x + 10, y + 5 - (Date.now() % 1000) / 50);
                    ctx.fillText('z', x + 20, y + 8 - (Date.now() % 1000) / 40);
                    ctx.fillText('Z', x + 30, y + 3 - (Date.now() % 1000) / 45);
                }
            }
            
            createParticles(x, y, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y));
                }
            }

            spawnMysteryMouse(blockX, blockY) {
                // Spawn mouse from the block position
                const mouse = new Mouse(blockX + 8, blockY + 20);

                // Make mouse run away fast to the right
                mouse.direction = 1;
                mouse.vx = 150; // Fast escape velocity
                mouse.vy = -100; // Pop out upward

                // Add to mice array
                this.mice.push(mouse);

                // Visual feedback
                this.createParticles(blockX + 8, blockY + 16, 10);
                this.playSound('collect');

                console.log('Mystery mouse spawned! Catch it before it escapes!');
            }

            playSound(type) {
                if (muted) return;
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'jump':
                        oscillator.frequency.value = 400;
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                        break;
                    case 'collect':
                        oscillator.frequency.value = 800;
                        oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                        break;
                    case 'hurt':
                        oscillator.frequency.value = 200;
                        oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.2);
                        break;
                }
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            }
            
            restart() {
                this.player = new Player();
                this.particles = [];
                this.fireballs = [];
                this.mice = [];
                this.dog = null;
                this.score = 0;
                this.lives = 3;
                this.hits = 0;
                this.speedBoost = 1;
                this.speedBoostTimer = 0;
                this.treatsCollected = 0;
                this.currentLevel = 1;
                this.startTime = Date.now();
                this.level = this.createLevel();
                this.fishTreats = this.createFishTreats();
                this.goalReached = false;
                this.initLevel();
                hideWinScreen();
            }
            
            showWinScreen() {
                const time = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('winTime').textContent = time;
                document.getElementById('winScore').textContent = this.score;
                document.getElementById('winHits').textContent = this.hits;
                document.getElementById('winOverlay').style.display = 'block';
            }
        }
        
        let game = null;
        let animationId = null;
        
        function gameLoop() {
            const now = Date.now();
            const dt = Math.min(now - game.lastTime, 100);
            game.lastTime = now;
            
            game.update(dt);
            game.draw();
            
            updateHUD();
            
            if (debugMode) {
                updateDebugOverlay();
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            game = new Game();
            game.lastTime = Date.now();
            gameLoop();
        }
        
        function updateHUD() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('time').textContent = Math.floor((Date.now() - game.startTime) / 1000);
            
            // Show level and speed boost
            const hudExtra = document.getElementById('hudExtra');
            if (!hudExtra) {
                const hud = document.getElementById('hud');
                const extraDiv = document.createElement('div');
                extraDiv.id = 'hudExtra';
                hud.appendChild(extraDiv);
            }
            document.getElementById('hudExtra').innerHTML = `
                <div>Level: ${game.currentLevel}</div>
                ${game.speedBoost > 1 ? `<div style="color:#FFD700">Speed: ${Math.floor(game.speedBoost * 100)}%</div>` : ''}
                ${game.currentLevel === 2 ? `<div>Treats: ${game.treatsCollected}</div>` : ''}
            `;
        }
        
        function updateDebugOverlay() {
            document.getElementById('fps').textContent = game.fps;
            document.getElementById('playerPos').textContent = 
                `${Math.floor(game.player.x)},${Math.floor(game.player.y)}`;
            document.getElementById('playerVel').textContent = 
                `${Math.floor(game.player.vx)},${Math.floor(game.player.vy)}`;
            document.getElementById('playerState').textContent = game.player.state;
        }
        
        function hideWinScreen() {
            document.getElementById('winOverlay').style.display = 'none';
        }
        
        function restartLevel() {
            game.restart();
            hideWinScreen();
        }
        
        // Mobile detection and orientation handling
        let currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
        
        function detectMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                      || ('ontouchstart' in window)
                      || (navigator.maxTouchPoints > 0);
            
            if (isMobile) {
                document.getElementById('mobileControls').style.display = 'block';
                document.getElementById('leftPanel').classList.add('hidden');
                setupTouchControls();
                autoFullscreenMobile();
                handleOrientationChange();
            }
        }
        
        // Auto-fullscreen for mobile
        function autoFullscreenMobile() {
            if (isMobile) {
                // Try to go fullscreen automatically on first user interaction
                const tryFullscreen = () => {
                    const container = document.getElementById('gameContainer');
                    
                    // Request fullscreen
                    if (container.requestFullscreen) {
                        container.requestFullscreen().catch(() => {});
                    } else if (container.webkitRequestFullscreen) {
                        container.webkitRequestFullscreen();
                    } else if (container.webkitRequestFullScreen) {
                        container.webkitRequestFullScreen();
                    }
                    
                    // Remove listener after first attempt
                    document.removeEventListener('touchstart', tryFullscreen);
                    document.removeEventListener('click', tryFullscreen);
                };
                
                // Add listeners for first user interaction
                document.addEventListener('touchstart', tryFullscreen, { once: true });
                document.addEventListener('click', tryFullscreen, { once: true });
            }
        }
        
        // Handle orientation changes
        function handleOrientationChange() {
            const newOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
            
            if (newOrientation !== currentOrientation) {
                currentOrientation = newOrientation;
                updateMobileControlsLayout();
            }
            
            resizeCanvas();
        }
        
        // Update mobile controls based on orientation
        function updateMobileControlsLayout() {
            const dpad = document.getElementById('dpad');
            const actionButtons = document.getElementById('actionButtons');
            
            if (currentOrientation === 'portrait') {
                // Portrait: controls at bottom with more spacing
                if (dpad) {
                    dpad.style.left = '20px';
                    dpad.style.bottom = '120px';
                }
                if (actionButtons) {
                    actionButtons.style.right = '20px';
                    actionButtons.style.bottom = '120px';
                }
            } else {
                // Landscape: controls at corners
                if (dpad) {
                    dpad.style.left = '20px';
                    dpad.style.bottom = '20px';
                }
                if (actionButtons) {
                    actionButtons.style.right = '20px';
                    actionButtons.style.bottom = '20px';
                }
            }
        }
        
        // Fullscreen toggle with better Safari support
        function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            const doc = document;
            
            // Check if currently in fullscreen
            const isInFullscreen = doc.fullscreenElement || 
                                  doc.mozFullScreenElement || 
                                  doc.webkitFullscreenElement || 
                                  doc.msFullscreenElement ||
                                  doc.webkitCurrentFullScreenElement; // Safari specific
            
            if (!isInFullscreen) {
                // Enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    // Safari specific - doesn't support Element.ALLOW_KEYBOARD_INPUT anymore
                    container.webkitRequestFullscreen();
                } else if (container.webkitRequestFullScreen) {
                    // Older Safari
                    container.webkitRequestFullScreen();
                } else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
                container.classList.add('fullscreen');
                isFullscreen = true;
                document.getElementById('fullscreenBtn').textContent = '⛶';
                resizeCanvas();
            } else {
                // Exit fullscreen
                if (doc.exitFullscreen) {
                    doc.exitFullscreen();
                } else if (doc.webkitExitFullscreen) {
                    doc.webkitExitFullscreen();
                } else if (doc.webkitCancelFullScreen) {
                    // Older Safari
                    doc.webkitCancelFullScreen();
                } else if (doc.mozCancelFullScreen) {
                    doc.mozCancelFullScreen();
                } else if (doc.msExitFullscreen) {
                    doc.msExitFullscreen();
                }
                container.classList.remove('fullscreen');
                isFullscreen = false;
                document.getElementById('fullscreenBtn').textContent = '⛶';
                resizeCanvas();
            }
        }
        
        // Setup touch controls
        function setupTouchControls() {
            const touchButtons = document.querySelectorAll('.touch-button, .dpad-button');
            
            touchButtons.forEach(button => {
                const key = button.getAttribute('data-key');
                
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    button.classList.add('pressed');
                    keys[key] = true;
                    
                    // Haptic feedback if available
                    if (navigator.vibrate) {
                        navigator.vibrate(10);
                    }
                });
                
                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    button.classList.remove('pressed');
                    keys[key] = false;
                });
                
                button.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    button.classList.remove('pressed');
                    keys[key] = false;
                });
            });
            
            // Prevent scrolling and zooming on mobile
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('#gameArea')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Prevent double-tap zoom
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === 'Tab') {
                e.preventDefault();
                if (debugMode) {
                    toggleMode();
                }
            }
            
            if (e.key === '`') {
                debugMode = !debugMode;
                document.getElementById('debugOverlay').style.display = 
                    debugMode ? 'block' : 'none';
                
                // Show/hide editor panel in debug mode
                if (debugMode) {
                    document.getElementById('leftPanel').classList.remove('hidden');
                } else if (!isMobile) {
                    document.getElementById('leftPanel').classList.add('hidden');
                }
            }
            
            // Ctrl+E to toggle editor in debug mode
            if (e.ctrlKey && e.key === 'e' && debugMode) {
                e.preventDefault();
                const panel = document.getElementById('leftPanel');
                panel.classList.toggle('hidden');
            }
            
            // F11 for fullscreen
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            }
            
            if (isKeyPressed('restart') && game) {
                game.restart();
            }
            
            if (isKeyPressed('mute')) {
                muted = !muted;
            }
            
            // Dev shortcut: Press 4 to jump to level 4
            if (e.key === '4' && debugMode) {
                game.currentLevel = 4;
                game.player.x = 100;
                game.player.y = 300;
                game.level = game.createLevel();
                game.fishTreats = game.createFishTreats();
                game.initLevel();
                game.goalReached = false;
            }
            
            // Dev shortcut: Press 5 to jump to level 5
            if (e.key === '5' && debugMode) {
                game.currentLevel = 5;
                game.player.x = 100;
                game.player.y = 300;
                game.level = game.createLevel();
                game.fishTreats = game.createFishTreats();
                game.initLevel();
                game.goalReached = false;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        function isKeyPressed(action) {
            return keyMap[action].some(key => keys[key]);
        }
        
        function switchTab(tab) {
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tab === 'editor') {
                document.querySelector('.tab-button:first-child').classList.add('active');
                document.getElementById('editorTab').classList.add('active');
                currentMode = 'editor';
            } else {
                document.querySelector('.tab-button:last-child').classList.add('active');
                document.getElementById('playTab').classList.add('active');
                currentMode = 'play';
                if (!game) {
                    startGame();
                }
            }
        }
        
        function toggleMode() {
            if (currentMode === 'editor') {
                switchTab('play');
            } else {
                switchTab('editor');
            }
        }
        
        function toggleCollapse(element) {
            element.classList.toggle('collapsed');
        }
        
        document.getElementById('sheetA').addEventListener('change', (e) => {
            loadSheet('A', e.target.files[0]);
        });
        
        document.getElementById('sheetB').addEventListener('change', (e) => {
            loadSheet('B', e.target.files[0]);
        });
        
        function loadSheet(sheetId, file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    sheets[sheetId].img = img;
                    
                    const thumbContainer = document.getElementById(`sheet${sheetId}Thumb`);
                    thumbContainer.innerHTML = '';
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = 96;
                    thumbCanvas.height = 96;
                    const thumbCtx = thumbCanvas.getContext('2d');
                    thumbCtx.imageSmoothingEnabled = false;
                    thumbCtx.drawImage(img, 0, 0, 96, 96);
                    thumbContainer.appendChild(thumbCanvas);
                    
                    if (sheetId === 'A') {
                        analyzeAndSetupGrid(img, sheetId);
                    }
                    
                    updateAnimationPreviews();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function analyzeAndSetupGrid(img, sheetId) {
            const cellWidth = img.width / 3;
            const cellHeight = img.height / 3;
            
            currentMapping.cells = [];
            
            const assignments = [
                'dodge_roll', 'run_1', 'idle_sit',
                'run_2', 'run_3', 'idle_sit_front',
                'crouch', 'jump_up', 'fall_down'
            ];
            
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const idx = r * 3 + c;
                    currentMapping.cells.push({
                        r: r + 1,
                        c: c + 1,
                        crop: [
                            Math.floor(c * cellWidth),
                            Math.floor(r * cellHeight),
                            Math.floor(cellWidth),
                            Math.floor(cellHeight)
                        ],
                        assign: assignments[idx],
                        pivot: [0.5, 1],
                        flipX: false
                    });
                }
            }
            
            if (img.width > img.height) {
                const fireballX = Math.floor(cellWidth * 2.3);
                const fireballY = Math.floor(cellHeight * 0.3);
                currentMapping.fireball = {
                    sheet: sheetId,
                    r: 1,
                    c: 3,
                    crop: [fireballX, fireballY, 16, 16]
                };
            }
            
            renderGridEditor();
            saveToLocalStorage();
        }
        
        function renderGridEditor() {
            const container = document.getElementById('gridEditor');
            container.innerHTML = '';
            
            if (!sheets[currentMapping.sheet].img) {
                container.innerHTML = '<p>Load a sprite sheet first</p>';
                return;
            }
            
            currentMapping.cells.forEach((cell, idx) => {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'grid-cell';
                cellDiv.innerHTML = `
                    <h4>Cell ${cell.r},${cell.c}</h4>
                    <select onchange="updateCellAssignment(${idx}, this.value)">
                        <option value="idle_sit" ${cell.assign === 'idle_sit' ? 'selected' : ''}>Idle Sit</option>
                        <option value="idle_sit_front" ${cell.assign === 'idle_sit_front' ? 'selected' : ''}>Idle Front</option>
                        <option value="run_1" ${cell.assign === 'run_1' ? 'selected' : ''}>Run 1</option>
                        <option value="run_2" ${cell.assign === 'run_2' ? 'selected' : ''}>Run 2</option>
                        <option value="run_3" ${cell.assign === 'run_3' ? 'selected' : ''}>Run 3</option>
                        <option value="jump_up" ${cell.assign === 'jump_up' ? 'selected' : ''}>Jump Up</option>
                        <option value="fall_down" ${cell.assign === 'fall_down' ? 'selected' : ''}>Fall Down</option>
                        <option value="crouch" ${cell.assign === 'crouch' ? 'selected' : ''}>Crouch</option>
                        <option value="dodge_roll" ${cell.assign === 'dodge_roll' ? 'selected' : ''}>Dodge Roll</option>
                        <option value="misc" ${cell.assign === 'misc' ? 'selected' : ''}>Misc</option>
                    </select>
                    <div class="cell-controls">
                        <input type="number" value="${cell.crop[0]}" onchange="updateCellCrop(${idx}, 0, this.value)" title="X">
                        <input type="number" value="${cell.crop[1]}" onchange="updateCellCrop(${idx}, 1, this.value)" title="Y">
                        <input type="number" value="${cell.crop[2]}" onchange="updateCellCrop(${idx}, 2, this.value)" title="Width">
                        <input type="number" value="${cell.crop[3]}" onchange="updateCellCrop(${idx}, 3, this.value)" title="Height">
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="flip_${idx}" ${cell.flipX ? 'checked' : ''} 
                               onchange="updateCellFlip(${idx}, this.checked)">
                        <label for="flip_${idx}">Flip X</label>
                    </div>
                    <button onclick="autoTrimCell(${idx})">Auto Trim</button>
                `;
                container.appendChild(cellDiv);
            });
        }
        
        function updateCellAssignment(idx, value) {
            currentMapping.cells[idx].assign = value;
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function updateCellCrop(idx, cropIdx, value) {
            currentMapping.cells[idx].crop[cropIdx] = parseInt(value);
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function updateCellFlip(idx, value) {
            currentMapping.cells[idx].flipX = value;
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function autoTrimCell(idx) {
            const cell = currentMapping.cells[idx];
            const img = sheets[currentMapping.sheet].img;
            if (!img) return;
            
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            const pixels = imageData.data;
            
            let minX = cell.crop[0] + cell.crop[2];
            let minY = cell.crop[1] + cell.crop[3];
            let maxX = cell.crop[0];
            let maxY = cell.crop[1];
            
            for (let y = cell.crop[1]; y < cell.crop[1] + cell.crop[3]; y++) {
                for (let x = cell.crop[0]; x < cell.crop[0] + cell.crop[2]; x++) {
                    const idx = (y * img.width + x) * 4;
                    if (pixels[idx + 3] > 0) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            if (maxX > minX && maxY > minY) {
                cell.crop = [minX, minY, maxX - minX + 1, maxY - minY + 1];
                renderGridEditor();
                updateAnimationPreviews();
                saveToLocalStorage();
            }
        }
        
        function updateAnimationPreviews() {
            const container = document.getElementById('animationPreview');
            container.innerHTML = '';
            
            const states = ['idle_sit', 'run', 'jump_up', 'fall_down', 'crouch', 'dodge_roll'];
            const scales = [1, 2, 4];
            
            states.forEach(state => {
                const frames = getFramesForState(state);
                if (frames.length === 0) return;
                
                scales.forEach(s => {
                    const item = document.createElement('div');
                    item.className = 'anim-preview-item';
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 32 * s;
                    canvas.height = 32 * s;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    
                    let frameIdx = 0;
                    const animate = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        const frame = frames[frameIdx % frames.length];
                        if (frame && sheets[currentMapping.sheet].img) {
                            ctx.drawImage(
                                sheets[currentMapping.sheet].img,
                                frame.crop[0], frame.crop[1], frame.crop[2], frame.crop[3],
                                0, 0, canvas.width, canvas.height
                            );
                        }
                        frameIdx++;
                    };
                    
                    animate();
                    setInterval(animate, 200);
                    
                    const label = document.createElement('label');
                    label.textContent = `${state} ${s}x`;
                    
                    item.appendChild(canvas);
                    item.appendChild(label);
                    container.appendChild(item);
                });
            });
        }
        
        function getFramesForState(state) {
            if (state === 'run') {
                return ['run_1', 'run_2', 'run_3']
                    .map(s => currentMapping.cells.find(c => c.assign === s))
                    .filter(c => c);
            }
            return currentMapping.cells.filter(c => c.assign === state);
        }
        
        function exportSettings() {
            const data = JSON.stringify(currentMapping, null, 2);
            const textarea = document.getElementById('jsonData');
            textarea.value = data;
            textarea.style.display = 'block';
            textarea.select();
            document.execCommand('copy');
            alert('Settings copied to clipboard!');
        }
        
        function importSettings() {
            const textarea = document.getElementById('jsonData');
            textarea.style.display = 'block';
            textarea.value = '';
            textarea.placeholder = 'Paste JSON here and press Enter';
            textarea.focus();
            
            textarea.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    try {
                        const data = JSON.parse(textarea.value);
                        currentMapping = data;
                        renderGridEditor();
                        updateAnimationPreviews();
                        saveToLocalStorage();
                        textarea.style.display = 'none';
                        alert('Settings imported successfully!');
                    } catch (err) {
                        alert('Invalid JSON data');
                    }
                }
            };
        }
        
        function resetDefaults() {
            currentMapping = JSON.parse(JSON.stringify(defaultMapping));
            renderGridEditor();
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function saveToLocalStorage() {
            localStorage.setItem('catPlatformerSettings', JSON.stringify({
                mapping: currentMapping,
                physics: physics,
                keyMap: keyMap,
                scale: scale
            }));
        }
        
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('catPlatformerSettings');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.mapping) currentMapping = data.mapping;
                    if (data.physics) Object.assign(physics, data.physics);
                    if (data.keyMap) Object.assign(keyMap, data.keyMap);
                    if (data.scale) scale = data.scale;
                } catch (err) {
                    console.error('Failed to load settings:', err);
                }
            }
        }
        
        function openKeyRemapping() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #16213e;
                padding: 20px;
                border: 2px solid #0f3460;
                z-index: 1000;
            `;
            
            modal.innerHTML = '<h3>Press a key for each action:</h3>';
            
            const actions = Object.keys(keyMap);
            let currentAction = 0;
            
            const updateModal = () => {
                if (currentAction >= actions.length) {
                    document.body.removeChild(modal);
                    saveToLocalStorage();
                    return;
                }
                
                modal.innerHTML = `
                    <h3>Press a key for: ${actions[currentAction]}</h3>
                    <p>Current: ${keyMap[actions[currentAction]].join(', ')}</p>
                `;
            };
            
            updateModal();
            
            const handleKey = (e) => {
                e.preventDefault();
                keyMap[actions[currentAction]] = [e.key];
                currentAction++;
                updateModal();
                
                if (currentAction >= actions.length) {
                    window.removeEventListener('keydown', handleKey);
                }
            };
            
            window.addEventListener('keydown', handleKey);
            document.body.appendChild(modal);
        }
        
        document.getElementById('gravity').addEventListener('input', (e) => {
            physics.gravity = parseFloat(e.target.value);
            document.getElementById('gravityVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('jumpForce').addEventListener('input', (e) => {
            physics.jumpForce = parseFloat(e.target.value);
            document.getElementById('jumpForceVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('moveSpeed').addEventListener('input', (e) => {
            physics.moveSpeed = parseFloat(e.target.value);
            document.getElementById('moveSpeedVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('friction').addEventListener('input', (e) => {
            physics.friction = parseFloat(e.target.value);
            document.getElementById('frictionVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('coyoteTime').addEventListener('input', (e) => {
            physics.coyoteTime = parseFloat(e.target.value);
            document.getElementById('coyoteVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('jumpBuffer').addEventListener('input', (e) => {
            physics.jumpBuffer = parseFloat(e.target.value);
            document.getElementById('jumpBufferVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('uiScale').addEventListener('input', (e) => {
            scale = parseInt(e.target.value);
            document.getElementById('scaleVal').textContent = scale;
            resizeCanvas();
            saveToLocalStorage();
        });
        
        document.getElementById('highContrast').addEventListener('change', (e) => {
            highContrast = e.target.checked;
            document.body.classList.toggle('high-contrast', highContrast);
        });
        
        document.getElementById('reducedMotion').addEventListener('change', (e) => {
            reducedMotion = e.target.checked;
        });
        
        function resizeCanvas() {
            // For mobile, use full viewport
            if (isMobile) {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Base game dimensions
                const baseWidth = 400;
                const baseHeight = 240;
                
                // Calculate scale to fit full screen
                const scaleX = viewportWidth / baseWidth;
                const scaleY = viewportHeight / baseHeight;
                
                // Use contain scaling (fit within viewport maintaining aspect ratio)
                const fitScale = Math.min(scaleX, scaleY);
                
                // Set canvas dimensions
                const width = baseWidth * fitScale;
                const height = baseHeight * fitScale;
                
                canvas.width = baseWidth;
                canvas.height = baseHeight;
                canvas.style.width = Math.floor(width) + 'px';
                canvas.style.height = Math.floor(height) + 'px';
                
                // Center canvas if needed
                canvas.style.position = 'absolute';
                canvas.style.left = '50%';
                canvas.style.top = '50%';
                canvas.style.transform = 'translate(-50%, -50%)';
                
                // Update global scale
                scale = fitScale;
            } else {
                // Desktop sizing logic
                const leftPanelWidth = document.getElementById('leftPanel').classList.contains('hidden') ? 0 : 370;
                const maxWidth = window.innerWidth - leftPanelWidth - (isFullscreen ? 0 : 40);
                const maxHeight = window.innerHeight - (isFullscreen ? 0 : 40);
                
                // Base game dimensions
                const baseWidth = 400;
                const baseHeight = 240;
                
                // Calculate scale to fit screen
                let fitScale = Math.min(maxWidth / baseWidth, maxHeight / baseHeight);
                
                // Use integer scaling for pixel-perfect rendering on desktop
                if (!isFullscreen) {
                    fitScale = Math.floor(fitScale);
                    fitScale = Math.max(1, Math.min(fitScale, scale));
                }
                
                let width = baseWidth * fitScale;
                let height = baseHeight * fitScale;
                
                canvas.width = baseWidth;
                canvas.height = baseHeight;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                canvas.style.position = '';
                canvas.style.left = '';
                canvas.style.top = '';
                canvas.style.transform = '';
                
                // Update global scale
                if (isFullscreen) {
                    scale = fitScale;
                }
            }
        }
        
        window.addEventListener('resize', () => {
            if (isMobile) {
                handleOrientationChange();
            } else {
                resizeCanvas();
            }
        });
        
        // Add orientation change listener
        window.addEventListener('orientationchange', handleOrientationChange);
        
        loadFromLocalStorage();
        detectMobile();
        resizeCanvas();
        renderGridEditor();
        
        // Handle fullscreen change events (for ESC key, etc.)
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        function handleFullscreenChange() {
            const isInFullscreen = document.fullscreenElement || 
                                  document.webkitFullscreenElement || 
                                  document.mozFullScreenElement ||
                                  document.msFullscreenElement ||
                                  document.webkitCurrentFullScreenElement;
            
            if (!isInFullscreen) {
                document.getElementById('gameContainer').classList.remove('fullscreen');
                isFullscreen = false;
                const btn = document.getElementById('fullscreenBtn');
                if (btn) btn.textContent = '⛶';
                resizeCanvas();
            }
        }
        
        // Start game immediately if not in editor mode
        if (currentMode === 'play' && !game) {
            startGame();
        }
        
        // Load default sprite sheets from files
        function loadDefaultSheets() {
            // Try to load bowie_cat_3x3.png - use relative path
            const loadImage = (url) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            };
            
            // Load cat sheet A
            loadImage('./bowie_cat_3x3.png')
                .then(img => {
                    sheets.A.img = img;
                    analyzeAndSetupGrid(img, 'A');
                    updateSheetThumbnail('A', img);
                    console.log('Loaded bowie_cat_3x3.png successfully');
                })
                .catch(() => {
                    console.log('Could not load bowie_cat_3x3.png, using embedded default');
                    loadEmbeddedDefault();
                });
            
            // Try to load a second sheet if available
            loadImage('./cat_sheet_2.png')
                .then(img => {
                    sheets.B.img = img;
                    updateSheetThumbnail('B', img);
                })
                .catch(() => {
                    console.log('No second sheet found');
                });
            
            // Load dog sprite sheet
            loadImage('./bonbon_dog_3x3.png')
                .then(img => {
                    sheets.dog.img = img;
                    console.log('Dog sprite sheet loaded successfully:', img.width, 'x', img.height);
                    
                    // Update dog thumbnail
                    const thumbContainer = document.getElementById('dogThumb');
                    if (thumbContainer) {
                        thumbContainer.innerHTML = '';
                        const thumbCanvas = document.createElement('canvas');
                        thumbCanvas.width = 96;
                        thumbCanvas.height = 96;
                        const thumbCtx = thumbCanvas.getContext('2d');
                        thumbCtx.imageSmoothingEnabled = false;
                        thumbCtx.drawImage(img, 0, 0, 96, 96);
                        thumbContainer.appendChild(thumbCanvas);
                    }
                    
                    // Animate dog run preview
                    animateDogRunPreview();
                })
                .catch((err) => {
                    console.log('Could not load bonbon_dog_3x3.png:', err);
                });
        }
        
        // Animate dog run preview
        function animateDogRunPreview() {
            const canvas = document.getElementById('dogRunPreview');
            if (!canvas || !sheets.dog.img) return;
            
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            
            let frame = 0;
            const cellSize = sheets.dog.img.width / 3;
            
            // Run frames are in row 2, columns 1-3
            const runFrames = [
                {r: 2, c: 1},
                {r: 2, c: 2},
                {r: 2, c: 3}
            ];
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw current frame
                const currentFrame = runFrames[frame % runFrames.length];
                const sx = (currentFrame.c - 1) * cellSize;
                const sy = (currentFrame.r - 1) * cellSize;
                
                // Draw 3 frames side by side to show animation
                for (let i = 0; i < 3; i++) {
                    const f = runFrames[(frame + i) % runFrames.length];
                    const fsx = (f.c - 1) * cellSize;
                    const fsy = (f.r - 1) * cellSize;
                    ctx.drawImage(
                        sheets.dog.img,
                        fsx, fsy, cellSize, cellSize,
                        i * 40, 0, 40, 40
                    );
                }
                
                frame++;
                setTimeout(() => {
                    if (sheets.dog.img) {
                        requestAnimationFrame(animate);
                    }
                }, 200);
            }
            
            animate();
        }
        
        function updateSheetThumbnail(sheetId, img) {
            const thumbContainer = document.getElementById(`sheet${sheetId}Thumb`);
            thumbContainer.innerHTML = '';
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 96;
            thumbCanvas.height = 96;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.imageSmoothingEnabled = false;
            thumbCtx.drawImage(img, 0, 0, 96, 96);
            thumbContainer.appendChild(thumbCanvas);
        }
        
        function loadEmbeddedDefault() {
            const defaultSheetData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMS42/U4J6AAAB1BJREFUeF7tnT1sVUcQhR+JEEIgIYRAQkghpXtKp6RLSZeO0l06SneUlE5Jl5IuHaW7lJTu0qWkS0mXEiEQAglBBBICCQQS4vvm7F35+fl57+7szOy9u3ekI9vPz3fuzJm9e/funZ37zszMzMzMzFbBNTiCN/AZfsBv+BN/4Rf8iG/wEZ7BMVyz/6kGbuI5fIXfkfs6xnt4CHs70fC7eIFLKHvxpbF8jOv2VTc5iNdYxuJL4yni1n111RLNvoC6Fl8azxO4Zl9dlaQJR5AqniqG1+yrqooc/HeYLp7ahlftr6osn7GuL3+ZWOzrqvATTO/1JNjPViEp5xGM8xnOmu2iZxibyiQFbWMKYtzI6NcJ/0I6YZSPbXuDl/B3+BzMsjJBOOEJJFz1DGRwANI5uyGv4cjGtkPIsIBXaA+iAZ/gHlyEzA+sQj7DzQxn7YUPMHQzDvEawqTGZ7jb0dZN5OiJ+RLHcRSSCfEy7PUE8g6K5gK24TjchRwD5WDfwzGfQQ5fOgdNJBOQxXGQLMJFcDg5irxBjiHEGORQIoerj5BJ0F1Ir2w6sjqUF5BJ0Lfo0OQ2LCCTYCEJvJGk24cwQ0mjuItsA3kNsQo8jvdRdSJdJO5CMOcge3I2Hblo6DQntyF4ZkVyGRU3sALvZP7chhC4KoqiE1o6QzbiKqiCYsOT2xDE9IqhCxs2pCdtMkYnCJ+2RCcI5UQGBdgywVE4fRaUW8QQOm2Qb5i8EJw+CwqEz4LOC8g8CcJMz8SQbkdMzxQIgdNG+ZQlG7EENUQnvdGJPJPgvJjNF4RTRCdt1pV9CCZVKy8o79wQLpoTN/M5CnuQ3EYMgac5OU0LJ1a0F8JnP0nQCHKakE5bQs6BZAW6MJ9hISlqTvhJUBRu4lkT2Fvdxcu2gUyCLszrBEnIOLYJzoNswdkJvFfRCU46r7K+mZf9KEAayJOUO5E8TuiJqBRMOj+zD5Cf0cQcQKA5yI6YYQEfQCa5CZ/VpJxOkGQkBW3Hb1u2DPTDV6nKGJLTMN+JdQ12MKvQJJxykRnRJUi8C4BDEi+eoiEXnJJOgtx9QDQX4LYKFkGUlxCYFESTYJ8aJfhKH/cgzlvJOyUTJp8qC3AO0lGeSMlZzBKkc9iBQLpJL4Z0QNcSIq8TepKwhyC+Ybj8GJZ3jTJJVdCNQkkHdNk2kJcUksQQ7SJBgzCRcgrioJZcOQRFCy+WnNiB+EIl8BLMi/LuHE7CBP4Kx7sjvuHxMCyJtJy3wN9D8lBCkHKaH7TnNvgfhg8hHRgS05gWaBLGzJf8SRnGbp05N/IG4TgPJl8Ax8/OlkRh7Eb79vQJ8oGqxnBJJfhJEGiFlRZ8knCJsQQ/TggVT6iTdJaAFwklKjvNHjvfQd5KFdK5bklI2DhxQvhJzJNrNilOlGLvQBYiJTm8VCDXMqWJ1QVUo5cRJKJqQqBVeSHy0oeqHkbdJoXvCyKBJrwMu8gK+SkxJOkUJ9KhLhgjGlTyFEMQJ9AzIgqg4aMOiSSd4r2nEyWJtIBgC3A0QJNCkkR4CtHy3xHJsC8hdBQFbQTf1fBdJJ1ikNMu0smwb9qnJRnrBOJOQRU38ySRJlnVrHBdJHNyfyQgqz8SQQNyOsGxAUcBMw+qRlqA+xJyOqFyA7jf8n5VGzNu3Ln5p1aSDQCsQzrBnZzQhQF1cQJxhNg3qpMqJAekdT1eQo8kCOfNvOwryNsOhpJ5IaRzKpoQfwTxqOcD+pD5kQnOPcmKcGJFcQH+kJdCJj7D0Y9hCGfxTFSqBdY/I2nMhqScTqhkQnQCcdPuTZmQP7kROoqC5qOLjhgHqRJJP+EpRFWrITKROoG4x88dCHY+YuznQ+gE4TIJnBG9gy4NIH8ZhTKxXMLWYpGcuXTOSTCJlqfBNahvRtRmU6ZuZkT4SRAmkyAq0sSNOAr6HH52JY1bIRkD8Yq4Y5CJAa2SvlLyJiGQbJMAM++Rb7yHOAW9QBdJX5HgqGjBxRCXCGK1F3zZiCr2GzRTRIBn8oOQRU3iyMsm1kNqxkCOxuxNNhGSrGNLI7qx9M0JBzN6TRTqLETQlqLMLUoSvW8cJYM6yEEdhLwQ+QJydBJPhyfJJmXKPFu5oGxlAbmGLIsw1RPnI29QJIdXJcTD5PUy8xDEVDOioQxXNz4j6wRiaIuTz5Ad9iEfzOQKmOtZaExQBu1D5AuaKBLDJdxB8mCZ5HRfznLJbkKhG2MvoyB3pJ9tQ6Hfz7Cd4CxkEDYJ/Rt5+TtQ7jBCdRCRl9WXiQxOlUIXtC9B3O8/R/5g3qCKCUFO6vY9lJPcnhTyKZKi+zMsT7KECZORYTRlZhJOcrwrD7NJK3JENAcQdJJjQgR5KN+YOa0Mk0HV3rz7+y2TNRwXyKUAAAAASUVORK5CYII=';
            
            const img = new Image();
            img.onload = () => {
                sheets.A.img = img;
                analyzeAndSetupGrid(img, 'A');
                updateSheetThumbnail('A', img);
            };
            img.src = defaultSheetData;
        }
        
        // Load sheets on startup
        loadDefaultSheets();
    </script>
</body>
</html>