<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: monospace;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }
        
        #gameContainer {
            display: flex;
            height: 100vh;
        }
        
        #leftPanel {
            width: 350px;
            background: #16213e;
            overflow-y: auto;
            padding: 10px;
            border-right: 2px solid #0f3460;
        }
        
        #gameArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 2px solid #0f3460;
        }
        
        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .tab-button {
            flex: 1;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: none;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .tab-button:hover {
            background: #1e5f8e;
        }
        
        .tab-button.active {
            background: #e94560;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            background: #0f3460;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        
        .section h3 {
            margin-bottom: 10px;
            color: #f39c12;
            font-size: 14px;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 12px;
            color: #aaa;
        }
        
        input[type="range"],
        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: 4px;
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #333;
            font-family: monospace;
            font-size: 12px;
        }
        
        input[type="file"] {
            width: 100%;
            margin-bottom: 5px;
            font-size: 11px;
        }
        
        button {
            padding: 6px 12px;
            background: #e94560;
            color: #fff;
            border: none;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            margin: 2px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #ff6b6b;
        }
        
        .sprite-preview {
            background: #222;
            border: 1px solid #444;
            margin: 5px 0;
            padding: 5px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .grid-cell {
            display: inline-block;
            margin: 2px;
            padding: 5px;
            background: #1a1a2e;
            border: 1px solid #444;
        }
        
        .cell-controls {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .cell-controls input[type="number"] {
            width: 60px;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            color: #fff;
            font-size: 14px;
            z-index: 100;
        }
        
        #debugOverlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            color: #0f0;
            font-size: 11px;
            font-family: monospace;
            display: none;
            z-index: 100;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 5px 0;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
            padding: 5px;
            background: #1e5f8e;
            margin-bottom: 5px;
        }
        
        .collapsible:after {
            content: ' ▼';
        }
        
        .collapsible.collapsed:after {
            content: ' ▶';
        }
        
        .collapsible-content {
            transition: max-height 0.3s;
            overflow: hidden;
        }
        
        .collapsed + .collapsible-content {
            max-height: 0;
        }
        
        .animation-preview {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .anim-preview-item {
            text-align: center;
        }
        
        .anim-preview-item canvas {
            border: 1px solid #444;
            margin-bottom: 3px;
        }
        
        .anim-preview-item label {
            font-size: 10px;
        }
        
        .import-export-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        #winOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border: 2px solid #f39c12;
            text-align: center;
            z-index: 200;
        }
        
        #winOverlay h2 {
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .high-contrast {
            filter: contrast(1.5);
        }
        
        .high-contrast canvas {
            filter: drop-shadow(0 0 2px #000);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="leftPanel">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('editor')">Editor</button>
                <button class="tab-button" onclick="switchTab('play')">Play</button>
            </div>
            
            <div id="editorTab" class="tab-content active">
                <div class="section">
                    <h3>Sprite Sheets</h3>
                    <div class="control-group">
                        <label>Sheet A (Main Cat)</label>
                        <input type="file" id="sheetA" accept="image/png">
                        <div id="sheetAThumb" class="sprite-preview"></div>
                    </div>
                    <div class="control-group">
                        <label>Sheet B (Alt Cat)</label>
                        <input type="file" id="sheetB" accept="image/png">
                        <div id="sheetBThumb" class="sprite-preview"></div>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Grid Editor</h3>
                    <div id="gridEditor"></div>
                </div>
                
                <div class="section">
                    <h3>Animation Preview</h3>
                    <div id="animationPreview" class="animation-preview"></div>
                </div>
                
                <div class="section">
                    <h3>Import/Export</h3>
                    <div class="import-export-buttons">
                        <button onclick="exportSettings()">Export JSON</button>
                        <button onclick="importSettings()">Import JSON</button>
                        <button onclick="resetDefaults()">Reset Defaults</button>
                    </div>
                    <textarea id="jsonData" style="width:100%; height:100px; margin-top:5px; display:none;"></textarea>
                </div>
            </div>
            
            <div id="playTab" class="tab-content">
                <div class="section">
                    <h3>Game Controls</h3>
                    <div style="font-size: 12px; line-height: 1.5;">
                        <div>Move: A/D or ←/→</div>
                        <div>Jump: Space/W/↑</div>
                        <div>Crouch: S/↓</div>
                        <div>Sit: Q</div>
                        <div>Dodge: Shift</div>
                        <div>Restart: R</div>
                        <div>Toggle Mode: Tab</div>
                        <div>Debug: ~</div>
                        <div>Mute: M</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="collapsible" onclick="toggleCollapse(this)">Physics Tuning</div>
                    <div class="collapsible-content">
                        <div class="control-group">
                            <label>Gravity: <span id="gravityVal">500</span></label>
                            <input type="range" id="gravity" min="100" max="1000" value="500">
                        </div>
                        <div class="control-group">
                            <label>Jump Force: <span id="jumpForceVal">250</span></label>
                            <input type="range" id="jumpForce" min="100" max="400" value="250">
                        </div>
                        <div class="control-group">
                            <label>Move Speed: <span id="moveSpeedVal">150</span></label>
                            <input type="range" id="moveSpeed" min="50" max="300" value="150">
                        </div>
                        <div class="control-group">
                            <label>Friction: <span id="frictionVal">0.8</span></label>
                            <input type="range" id="friction" min="0.5" max="1" step="0.05" value="0.8">
                        </div>
                        <div class="control-group">
                            <label>Coyote Time (ms): <span id="coyoteVal">80</span></label>
                            <input type="range" id="coyoteTime" min="0" max="200" value="80">
                        </div>
                        <div class="control-group">
                            <label>Jump Buffer (ms): <span id="jumpBufferVal">100</span></label>
                            <input type="range" id="jumpBuffer" min="0" max="200" value="100">
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Accessibility</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="highContrast">
                        <label for="highContrast">High Contrast</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="reducedMotion">
                        <label for="reducedMotion">Reduced Motion</label>
                    </div>
                    <div class="control-group">
                        <label>UI Scale: <span id="scaleVal">2</span>x</label>
                        <input type="range" id="uiScale" min="1" max="4" value="2">
                    </div>
                </div>
                
                <div class="section">
                    <h3>Key Remapping</h3>
                    <button onclick="openKeyRemapping()">Configure Keys</button>
                </div>
            </div>
        </div>
        
        <div id="gameArea">
            <canvas id="gameCanvas"></canvas>
            <div id="hud">
                <div>Score: <span id="score">0</span></div>
                <div>Lives: <span id="lives">3</span></div>
                <div>Time: <span id="time">0</span>s</div>
            </div>
            <div id="debugOverlay">
                <div>FPS: <span id="fps">0</span></div>
                <div>Pos: <span id="playerPos">0,0</span></div>
                <div>Vel: <span id="playerVel">0,0</span></div>
                <div>State: <span id="playerState">idle</span></div>
            </div>
            <div id="winOverlay">
                <h2>Level Complete!</h2>
                <div>Time: <span id="winTime">0</span>s</div>
                <div>Score: <span id="winScore">0</span></div>
                <div>Hits: <span id="winHits">0</span></div>
                <button onclick="restartLevel()">Play Again</button>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        let currentMode = 'editor';
        let scale = 2;
        let highContrast = false;
        let reducedMotion = false;
        let muted = false;
        let debugMode = false;
        
        const sheets = {
            A: { img: null, cells: [] },
            B: { img: null, cells: [] }
        };
        
        const defaultMapping = {
            sheet: 'A',
            cells: [
                {r:1, c:1, crop:[0,0,32,32], assign:'dodge_roll', pivot:[0.5,1], flipX:false},
                {r:1, c:2, crop:[32,0,32,32], assign:'run_1', pivot:[0.5,1], flipX:false},
                {r:1, c:3, crop:[64,0,32,32], assign:'idle_sit', pivot:[0.5,1], flipX:false},
                {r:2, c:1, crop:[0,32,32,32], assign:'run_2', pivot:[0.5,1], flipX:false},
                {r:2, c:2, crop:[32,32,32,32], assign:'run_3', pivot:[0.5,1], flipX:false},
                {r:2, c:3, crop:[64,32,32,32], assign:'idle_sit_front', pivot:[0.5,1], flipX:false},
                {r:3, c:1, crop:[0,64,32,32], assign:'crouch', pivot:[0.5,1], flipX:false},
                {r:3, c:2, crop:[32,64,32,32], assign:'jump_up', pivot:[0.5,1], flipX:false},
                {r:3, c:3, crop:[64,64,32,32], assign:'fall_down', pivot:[0.5,1], flipX:false}
            ],
            fireball: null
        };
        
        let currentMapping = JSON.parse(JSON.stringify(defaultMapping));
        
        const physics = {
            gravity: 500,
            jumpForce: 250,
            moveSpeed: 150,
            friction: 0.8,
            coyoteTime: 80,
            jumpBuffer: 100
        };
        
        const keyMap = {
            left: ['ArrowLeft', 'a', 'A'],
            right: ['ArrowRight', 'd', 'D'],
            jump: [' ', 'w', 'W', 'ArrowUp'],
            crouch: ['s', 'S', 'ArrowDown'],
            sit: ['q', 'Q'],
            dodge: ['Shift'],
            restart: ['r', 'R'],
            toggleMode: ['Tab'],
            debug: ['`'],
            mute: ['m', 'M']
        };
        
        const keys = {};
        const animations = {};
        
        class Player {
            constructor() {
                this.x = 100;
                this.y = 300;
                this.vx = 0;
                this.vy = 0;
                this.width = 24;
                this.height = 28;
                this.state = 'idle_sit';
                this.facing = 1;
                this.grounded = false;
                this.lastGroundedTime = 0;
                this.jumpBufferTime = 0;
                this.dodging = false;
                this.dodgeTimer = 0;
                this.invulnerable = false;
                this.invulnTimer = 0;
                this.animFrame = 0;
                this.animTimer = 0;
                this.sitting = false;
                this.crouching = false;
                this.dead = false;
                this.prevY = 300;
            }
            
            update(dt) {
                if (this.dead) return;
                
                const wasGrounded = this.grounded;
                this.grounded = this.checkGrounded();
                
                if (this.grounded && !wasGrounded) {
                    this.land();
                }
                
                if (this.grounded) {
                    this.lastGroundedTime = Date.now();
                }
                
                if (this.dodging) {
                    this.dodgeTimer -= dt;
                    if (this.dodgeTimer <= 0) {
                        this.dodging = false;
                        this.invulnerable = false;
                    }
                }
                
                if (this.invulnerable && !this.dodging) {
                    this.invulnTimer -= dt;
                    if (this.invulnTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                this.handleInput(dt);
                
                this.vy += physics.gravity * dt / 1000;
                
                this.prevY = this.y;
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                
                this.checkCollisions();
                
                if (!this.dodging) {
                    this.vx *= Math.pow(physics.friction, dt / 16);
                }
                
                this.updateState();
                this.updateAnimation(dt);
            }
            
            handleInput(dt) {
                if (isKeyPressed('left')) {
                    this.vx = -physics.moveSpeed;
                    this.facing = -1;
                    this.sitting = false;
                }
                if (isKeyPressed('right')) {
                    this.vx = physics.moveSpeed;
                    this.facing = 1;
                    this.sitting = false;
                }
                
                if (isKeyPressed('jump')) {
                    this.jumpBufferTime = Date.now();
                }
                
                const canJump = this.grounded || 
                    (Date.now() - this.lastGroundedTime < physics.coyoteTime);
                const wantsJump = Date.now() - this.jumpBufferTime < physics.jumpBuffer;
                
                if (canJump && wantsJump) {
                    this.vy = -physics.jumpForce;
                    this.jumpBufferTime = 0;
                    this.sitting = false;
                    this.crouching = false;
                }
                
                if (!isKeyPressed('jump') && this.vy < 0) {
                    this.vy *= 0.5;
                }
                
                if (isKeyPressed('crouch')) {
                    this.crouching = true;
                    this.sitting = false;
                } else {
                    this.crouching = false;
                }
                
                if (isKeyPressed('sit')) {
                    this.sitting = true;
                    this.crouching = false;
                }
                
                if (isKeyPressed('dodge') && !this.dodging && this.grounded) {
                    this.dodge();
                }
            }
            
            dodge() {
                this.dodging = true;
                this.invulnerable = true;
                this.dodgeTimer = 250;
                this.vx = this.facing * physics.moveSpeed * 2;
                this.height = 16;
            }
            
            land() {
                if (!reducedMotion && game) {
                    game.createParticles(this.x, this.y + this.height, 5);
                }
            }
            
            updateState() {
                const oldState = this.state;
                
                if (this.dodging) {
                    this.state = 'dodge_roll';
                } else if (this.crouching) {
                    this.state = 'crouch';
                } else if (!this.grounded) {
                    this.state = this.vy < 0 ? 'jump_up' : 'fall_down';
                } else if (Math.abs(this.vx) > 10) {
                    this.state = 'run';
                } else if (this.sitting) {
                    this.state = 'idle_sit';
                } else {
                    this.state = 'idle_sit';
                }
                
                if (oldState !== this.state) {
                    this.animFrame = 0;
                    this.animTimer = 0;
                }
                
                if (!this.dodging && this.height === 16) {
                    this.height = 28;
                }
            }
            
            updateAnimation(dt) {
                this.animTimer += dt;
                
                const animSpeed = this.state === 'run' ? 100 : 150;
                
                if (this.animTimer >= animSpeed) {
                    this.animTimer = 0;
                    this.animFrame++;
                    
                    const frameCount = this.getFrameCount();
                    if (this.animFrame >= frameCount) {
                        this.animFrame = 0;
                    }
                }
            }
            
            getFrameCount() {
                switch(this.state) {
                    case 'run': return 3;
                    case 'dodge_roll': return 1;
                    default: return 1;
                }
            }
            
            checkGrounded() {
                // Check floor
                if (this.y >= 400 - this.height) {
                    return true;
                }
                
                // Check if standing on a platform tile
                const tileX = Math.floor((this.x + this.width/2) / 16);
                const tileY = Math.floor((this.y + this.height + 2) / 16);
                
                if (game && game.level[tileY] && game.level[tileY][tileX] === 1) {
                    return true;
                }
                
                return false;
            }
            
            checkCollisions() {
                // Floor collision
                if (this.y > 400 - this.height) {
                    this.y = 400 - this.height;
                    this.vy = 0;
                    this.grounded = true;
                }
                
                // Platform tile collisions
                if (game) {
                    // Check multiple points along the player's bottom edge
                    for (let xOffset = 2; xOffset < this.width - 2; xOffset += 4) {
                        const checkX = this.x + xOffset;
                        const tileX = Math.floor(checkX / 16);
                        const tileY = Math.floor((this.y + this.height) / 16);
                        
                        if (game.level[tileY] && game.level[tileY][tileX] === 1) {
                            // Check if we're falling onto the platform (not jumping through)
                            if (this.vy > 0 && this.prevY + this.height <= tileY * 16 + 4) {
                                this.y = tileY * 16 - this.height;
                                this.vy = 0;
                                this.grounded = true;
                                break;
                            }
                        }
                    }
                    
                    // Side collisions with platforms
                    const leftTileX = Math.floor(this.x / 16);
                    const rightTileX = Math.floor((this.x + this.width) / 16);
                    const centerTileY = Math.floor((this.y + this.height/2) / 16);
                    
                    // Left collision
                    if (game.level[centerTileY] && game.level[centerTileY][leftTileX] === 1) {
                        if (this.vx < 0) {
                            this.x = (leftTileX + 1) * 16;
                            this.vx = 0;
                        }
                    }
                    
                    // Right collision
                    if (game.level[centerTileY] && game.level[centerTileY][rightTileX] === 1) {
                        if (this.vx > 0) {
                            this.x = rightTileX * 16 - this.width;
                            this.vx = 0;
                        }
                    }
                    
                    // Head collision
                    const headTileY = Math.floor(this.y / 16);
                    const headTileX = Math.floor((this.x + this.width/2) / 16);
                    
                    if (game.level[headTileY] && game.level[headTileY][headTileX] === 1) {
                        if (this.vy < 0) {
                            this.y = (headTileY + 1) * 16;
                            this.vy = 0;
                        }
                    }
                    
                    // Lava collision
                    const lavaCheckY = Math.floor((this.y + this.height - 2) / 16);
                    const lavaCheckX = Math.floor((this.x + this.width/2) / 16);
                    
                    if (game.level[lavaCheckY] && game.level[lavaCheckY][lavaCheckX] === 2) {
                        this.hurt();
                    }
                }
                
                // World bounds
                if (this.x < 0) this.x = 0;
                if (this.x > 800 - this.width) this.x = 800 - this.width;
            }
            
            hurt() {
                if (this.invulnerable || this.dead) return;
                
                this.invulnerable = true;
                this.invulnTimer = 1000;
                
                game.lives--;
                game.hits++;
                
                if (game.lives <= 0) {
                    this.die();
                }
            }
            
            die() {
                this.dead = true;
                this.state = 'dead';
                setTimeout(() => game.restart(), 2000);
            }
            
            draw(ctx) {
                ctx.save();
                
                if (this.invulnerable) {
                    ctx.globalAlpha = Math.sin(Date.now() * 0.01) > 0 ? 1 : 0.5;
                }
                
                const sprite = this.getSprite();
                if (sprite && sprite.img) {
                    ctx.translate(this.x + this.width/2, this.y + this.height);
                    
                    if (this.facing === -1) {
                        ctx.scale(-1, 1);
                    }
                    
                    const crop = sprite.crop;
                    ctx.drawImage(
                        sprite.img,
                        crop[0], crop[1], crop[2], crop[3],
                        -this.width/2, -this.height, this.width, this.height
                    );
                } else {
                    ctx.fillStyle = this.invulnerable ? '#ff0000' : '#ffffff';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                
                ctx.restore();
            }
            
            getSprite() {
                const mapping = this.getMappingForState();
                if (!mapping) return null;
                
                const sheet = sheets[currentMapping.sheet];
                if (!sheet || !sheet.img) return null;
                
                return {
                    img: sheet.img,
                    crop: mapping.crop,
                    pivot: mapping.pivot
                };
            }
            
            getMappingForState() {
                let searchState = this.state;
                
                if (this.state === 'run') {
                    const frameMap = ['run_1', 'run_2', 'run_3'];
                    searchState = frameMap[this.animFrame % 3];
                }
                
                return currentMapping.cells.find(c => c.assign === searchState);
            }
        }
        
        class Particle {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 10;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = -Math.random() * 100 - 50;
                this.life = 500;
                this.maxLife = 500;
            }
            
            update(dt) {
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                this.vy += 300 * dt / 1000;
                this.life -= dt;
            }
            
            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life / this.maxLife})`;
                ctx.fillRect(this.x, this.y, 2, 2);
            }
        }
        
        class Fireball {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = 12;
                this.height = 12;
            }
            
            update(dt) {
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                this.vy += 200 * dt / 1000;
                
                // Check collision with platform tiles
                if (game) {
                    const tileX = Math.floor((this.x + this.width/2) / 16);
                    const tileY = Math.floor((this.y + this.height/2) / 16);
                    
                    if (game.level[tileY] && game.level[tileY][tileX] === 1) {
                        // Fireball hits platform, reset it
                        this.reset();
                        return;
                    }
                }
                
                // Reset if falls off screen
                if (this.y > 450) {
                    this.reset();
                }
            }
            
            reset() {
                this.y = -50;
                this.x = 100 + Math.random() * 600;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = 0;
            }
            
            draw(ctx) {
                if (currentMapping.fireball) {
                    const sheet = sheets[currentMapping.fireball.sheet];
                    if (sheet && sheet.img) {
                        const crop = currentMapping.fireball.crop;
                        ctx.drawImage(
                            sheet.img,
                            crop[0], crop[1], crop[2], crop[3],
                            this.x, this.y, this.width, this.height
                        );
                        return;
                    }
                }
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(this.x + 6, this.y + 6, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(this.x + 6, this.y + 6, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            checkCollision(player) {
                if (player.invulnerable) return false;
                
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
        }
        
        class Mouse {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = 0;
                this.width = 8;
                this.height = 6;
                this.grounded = false;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.moveTimer = 0;
                this.caught = false;
                this.jumpCooldown = 0;
            }
            
            update(dt) {
                if (this.caught) return;
                
                this.jumpCooldown -= dt;
                this.moveTimer += dt;
                
                // Change direction randomly
                if (this.moveTimer > 1000 + Math.random() * 2000) {
                    this.moveTimer = 0;
                    this.direction = Math.random() > 0.5 ? 1 : -1;
                    
                    // Sometimes jump
                    if (Math.random() > 0.7 && this.grounded && this.jumpCooldown <= 0) {
                        this.vy = -150;
                        this.jumpCooldown = 1000;
                    }
                }
                
                // Move
                this.vx = this.direction * 50;
                
                // Physics
                this.vy += 500 * dt / 1000;
                this.x += this.vx * dt / 1000;
                this.y += this.vy * dt / 1000;
                
                // Ground collision
                this.grounded = false;
                if (this.y > 400 - this.height) {
                    this.y = 400 - this.height;
                    this.vy = 0;
                    this.grounded = true;
                }
                
                // Platform collisions
                if (game && game.currentLevel === 2) {
                    const tileX = Math.floor((this.x + this.width/2) / 16);
                    const tileY = Math.floor((this.y + this.height) / 16);
                    
                    if (game.level[tileY] && game.level[tileY][tileX] === 1) {
                        if (this.vy > 0) {
                            this.y = tileY * 16 - this.height;
                            this.vy = 0;
                            this.grounded = true;
                        }
                    }
                }
                
                // World bounds
                if (this.x < 0 || this.x > 800 - this.width) {
                    this.direction *= -1;
                    this.x = Math.max(0, Math.min(this.x, 800 - this.width));
                }
            }
            
            draw(ctx) {
                if (this.caught) return;
                
                // Draw simple pixel mouse
                ctx.fillStyle = '#808080';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Tail
                ctx.fillRect(this.x - 4, this.y + 2, 4, 2);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 1, this.y + 1, 1, 1);
                ctx.fillRect(this.x + 3, this.y + 1, 1, 1);
                
                // Ears
                ctx.fillStyle = '#808080';
                ctx.fillRect(this.x + 1, this.y - 2, 2, 2);
                ctx.fillRect(this.x + 5, this.y - 2, 2, 2);
            }
            
            checkCaught(player) {
                if (this.caught) return false;
                
                // Only catch if player is moving
                if (Math.abs(player.vx) < 10) return false;
                
                const dx = Math.abs(this.x - player.x);
                const dy = Math.abs(this.y - player.y);
                
                if (dx < player.width && dy < player.height) {
                    this.caught = true;
                    return true;
                }
                return false;
            }
            
            checkCollisionWithStaticCat(player) {
                if (this.caught) return false;
                
                // Only collide if cat is stationary
                if (Math.abs(player.vx) > 10) return false;
                
                const dx = Math.abs(this.x - player.x);
                const dy = Math.abs(this.y - player.y);
                
                return dx < player.width && dy < player.height;
            }
        }
        
        class Game {
            constructor() {
                this.player = new Player();
                this.particles = [];
                this.fireballs = [];
                this.mice = [];
                this.camera = { x: 0, y: 0 };
                this.score = 0;
                this.lives = 3;
                this.hits = 0;
                this.speedBoost = 1;
                this.speedBoostTimer = 0;
                this.treatsCollected = 0;
                this.startTime = Date.now();
                this.lastTime = Date.now();
                this.fps = 0;
                this.frameCount = 0;
                this.fpsTimer = 0;
                this.currentLevel = 1;
                this.level = this.createLevel();
                this.fishTreats = this.createFishTreats();
                this.goalReached = false;
                
                this.initLevel();
            }
            
            initLevel() {
                if (this.currentLevel === 1) {
                    this.initFireballs();
                } else if (this.currentLevel === 2) {
                    this.initMice();
                    this.fireballs = [];
                }
            }
            
            initFireballs() {
                this.fireballs = [];
                for (let i = 0; i < 3; i++) {
                    this.fireballs.push(new Fireball(
                        200 + i * 200,
                        100,
                        (Math.random() - 0.5) * 100,
                        0
                    ));
                }
            }
            
            initMice() {
                this.mice = [];
                // Create 8 mice at various positions
                const mousePositions = [
                    {x: 200, y: 350},
                    {x: 350, y: 350},
                    {x: 500, y: 350},
                    {x: 180, y: 300},
                    {x: 320, y: 280},
                    {x: 450, y: 250},
                    {x: 600, y: 350},
                    {x: 700, y: 350}
                ];
                
                mousePositions.forEach(pos => {
                    this.mice.push(new Mouse(pos.x, pos.y));
                });
            }
            
            createLevel() {
                const level = [];
                
                if (this.currentLevel === 1) {
                    // Level 1 - Platformer with fireballs
                    for (let y = 0; y < 30; y++) {
                        level[y] = [];
                        for (let x = 0; x < 50; x++) {
                            if (y === 25) {
                                // Main ground
                                level[y][x] = 1;
                            } else if (y === 20 && x >= 10 && x <= 14) {
                                // Platform 1
                                level[y][x] = 1;
                            } else if (y === 18 && x >= 20 && x <= 24) {
                                // Platform 2
                                level[y][x] = 1;
                            } else if (y === 22 && x >= 30 && x <= 34) {
                                // Platform 3
                                level[y][x] = 1;
                            } else if (y === 15 && x >= 25 && x <= 29) {
                                // Higher platform
                                level[y][x] = 1;
                            } else if (y === 16 && x >= 40 && x <= 44) {
                                // Another platform
                                level[y][x] = 1;
                            } else if (y > 26 && x >= 15 && x <= 19) {
                                // Lava pit
                                level[y][x] = 2;
                            } else {
                                level[y][x] = 0;
                            }
                        }
                    }
                } else if (this.currentLevel === 2) {
                    // Level 2 - Mouse catching arena
                    for (let y = 0; y < 30; y++) {
                        level[y] = [];
                        for (let x = 0; x < 50; x++) {
                            if (y === 25) {
                                // Main ground
                                level[y][x] = 1;
                            } else if (y === 22 && x >= 8 && x <= 12) {
                                // Small platform left
                                level[y][x] = 1;
                            } else if (y === 20 && x >= 18 && x <= 22) {
                                // Mid platform
                                level[y][x] = 1;
                            } else if (y === 22 && x >= 28 && x <= 32) {
                                // Small platform right
                                level[y][x] = 1;
                            } else if (y === 18 && x >= 38 && x <= 42) {
                                // High platform
                                level[y][x] = 1;
                            } else {
                                level[y][x] = 0;
                            }
                        }
                    }
                }
                
                return level;
            }
            
            createFishTreats() {
                return [
                    {x: 240, y: 280, collected: false},
                    {x: 360, y: 250, collected: false},
                    {x: 520, y: 330, collected: false},
                    {x: 600, y: 200, collected: false}
                ];
            }
            
            update(dt) {
                // Update speed boost timer
                if (this.speedBoostTimer > 0) {
                    this.speedBoostTimer -= dt;
                    if (this.speedBoostTimer <= 0) {
                        this.speedBoost = 1;
                    }
                }
                
                // Apply speed boost to physics
                const originalSpeed = physics.moveSpeed;
                physics.moveSpeed = originalSpeed * this.speedBoost;
                
                this.player.update(dt);
                
                // Restore original speed
                physics.moveSpeed = originalSpeed;
                
                this.particles = this.particles.filter(p => {
                    p.update(dt);
                    return p.life > 0;
                });
                
                // Level 1 - Fireballs
                if (this.currentLevel === 1) {
                    this.fireballs.forEach(f => {
                        f.update(dt);
                        if (f.checkCollision(this.player)) {
                            this.player.hurt();
                        }
                    });
                    
                    // Check goal
                    if (this.player.x > 750 && !this.goalReached) {
                        this.goalReached = true;
                        this.nextLevel();
                    }
                }
                
                // Level 2 - Mice
                if (this.currentLevel === 2) {
                    this.mice.forEach(mouse => {
                        mouse.update(dt);
                        
                        // Check if caught
                        if (mouse.checkCaught(this.player)) {
                            this.score += 200;
                            this.playSound('collect');
                            
                            // Check win condition
                            const uncaughtMice = this.mice.filter(m => !m.caught).length;
                            if (uncaughtMice === 0) {
                                this.showWinScreen();
                            }
                        }
                        
                        // Check collision with static cat
                        if (mouse.checkCollisionWithStaticCat(this.player)) {
                            if (this.treatsCollected > 0) {
                                // Eject treats
                                this.ejectTreats();
                                mouse.direction *= -1; // Bounce mouse away
                            }
                        }
                    });
                }
                
                // Collect treats
                this.fishTreats.forEach(fish => {
                    if (!fish.collected) {
                        const dx = Math.abs(this.player.x - fish.x);
                        const dy = Math.abs(this.player.y - fish.y);
                        if (dx < 20 && dy < 20) {
                            fish.collected = true;
                            this.score += 100;
                            this.treatsCollected++;
                            
                            // Add speed boost
                            this.speedBoost = Math.min(2, this.speedBoost + 0.15);
                            this.speedBoostTimer = 5000; // 5 seconds
                            
                            this.playSound('collect');
                        }
                    }
                });
                
                this.updateCamera();
                
                this.frameCount++;
                this.fpsTimer += dt;
                if (this.fpsTimer >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.fpsTimer = 0;
                }
            }
            
            ejectTreats() {
                const treatCount = Math.min(3, this.treatsCollected);
                this.treatsCollected = Math.max(0, this.treatsCollected - treatCount);
                
                // Create flying treats
                for (let i = 0; i < treatCount; i++) {
                    const angle = (Math.PI * 2 / treatCount) * i;
                    const speed = 150;
                    this.fishTreats.push({
                        x: this.player.x + this.player.width/2,
                        y: this.player.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 100,
                        collected: false,
                        flying: true
                    });
                }
                
                // Reduce speed boost
                this.speedBoost = Math.max(1, this.speedBoost - treatCount * 0.15);
                this.playSound('hurt');
            }
            
            nextLevel() {
                this.currentLevel = 2;
                this.player.x = 100;
                this.player.y = 300;
                this.level = this.createLevel();
                this.fishTreats = this.createFishTreats();
                this.initLevel();
                this.goalReached = false;
            }
            
            updateCamera() {
                const targetX = this.player.x - canvas.width / 2 / scale;
                const targetY = this.player.y - canvas.height / 2 / scale;
                
                this.camera.x += (targetX - this.camera.x) * 0.1;
                this.camera.y += (targetY - this.camera.y) * 0.1;
                
                this.camera.x = Math.max(0, Math.min(this.camera.x, 800 - canvas.width / scale));
                this.camera.y = Math.max(0, Math.min(this.camera.y, 480 - canvas.height / scale));
            }
            
            draw() {
                // Different background for level 2
                ctx.fillStyle = this.currentLevel === 2 ? '#4A5F7A' : '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.save();
                ctx.scale(scale, scale);
                ctx.translate(-this.camera.x, -this.camera.y);
                
                this.drawParallax();
                this.drawLevel();
                
                // Draw treats as goldfish crackers
                this.fishTreats.forEach(fish => {
                    if (!fish.collected) {
                        if (fish.flying) {
                            // Update flying treat physics
                            fish.x += fish.vx * 0.016;
                            fish.y += fish.vy * 0.016;
                            fish.vy += 500 * 0.016;
                            
                            // Stop when hits ground
                            if (fish.y > 390) {
                                fish.y = 390;
                                fish.flying = false;
                                fish.vx = 0;
                                fish.vy = 0;
                            }
                        }
                        
                        // Draw goldfish cracker shape
                        ctx.save();
                        ctx.translate(fish.x + 6, fish.y + 5);
                        ctx.rotate(Math.sin(Date.now() * 0.002 + fish.x) * 0.1);
                        
                        // Body (oval)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Tail
                        ctx.beginPath();
                        ctx.moveTo(4, 0);
                        ctx.lineTo(8, -2);
                        ctx.lineTo(8, 2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Eye
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-3, -1, 2, 2);
                        
                        // Smile
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.arc(-1, 0, 2, 0.2, Math.PI - 0.2, false);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                
                // Level 1 goal flag
                if (this.currentLevel === 1) {
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(760, 350, 30, 50);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(770, 340, 10, 20);
                }
                
                // Draw mice for level 2
                if (this.currentLevel === 2) {
                    this.mice.forEach(mouse => mouse.draw(ctx));
                    
                    // Draw mouse counter
                    const uncaughtMice = this.mice.filter(m => !m.caught).length;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '16px monospace';
                    ctx.fillText(`Mice: ${uncaughtMice}/${this.mice.length}`, 10, 30);
                }
                
                // Draw speed boost indicator
                if (this.speedBoost > 1) {
                    ctx.fillStyle = `rgba(255, 255, 0, ${0.3 + Math.sin(Date.now() * 0.01) * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(this.player.x + this.player.width/2, this.player.y + this.player.height/2, 
                            20 + Math.sin(Date.now() * 0.01) * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                this.particles.forEach(p => p.draw(ctx));
                this.fireballs.forEach(f => f.draw(ctx));
                this.player.draw(ctx);
                
                ctx.restore();
            }
            
            drawParallax() {
                ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
                for (let i = 0; i < 5; i++) {
                    const x = (i * 200 - this.camera.x * 0.3) % 1000;
                    const y = 100 + Math.sin(i) * 20;
                    ctx.fillRect(x, y, 150, 80);
                }
                
                ctx.fillStyle = 'rgba(80, 120, 80, 0.4)';
                for (let i = 0; i < 8; i++) {
                    const x = (i * 150 - this.camera.x * 0.5) % 1000;
                    const y = 200 + Math.sin(i * 2) * 15;
                    ctx.fillRect(x, y, 100, 100);
                }
            }
            
            drawLevel() {
                for (let y = 0; y < this.level.length; y++) {
                    for (let x = 0; x < this.level[y].length; x++) {
                        const tile = this.level[y][x];
                        if (tile === 1) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(x * 16, y * 16, 16, 16);
                            ctx.fillStyle = '#654321';
                            ctx.fillRect(x * 16 + 2, y * 16 + 2, 12, 12);
                        } else if (tile === 2) {
                            ctx.fillStyle = '#FF4500';
                            ctx.fillRect(x * 16, y * 16, 16, 16);
                            ctx.fillStyle = '#FF6347';
                            ctx.fillRect(x * 16 + 4, y * 16 + 4, 8, 8);
                        }
                    }
                }
            }
            
            createParticles(x, y, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y));
                }
            }
            
            playSound(type) {
                if (muted) return;
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'jump':
                        oscillator.frequency.value = 400;
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                        break;
                    case 'collect':
                        oscillator.frequency.value = 800;
                        oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                        break;
                    case 'hurt':
                        oscillator.frequency.value = 200;
                        oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.2);
                        break;
                }
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            }
            
            restart() {
                this.player = new Player();
                this.particles = [];
                this.fireballs = [];
                this.mice = [];
                this.score = 0;
                this.lives = 3;
                this.hits = 0;
                this.speedBoost = 1;
                this.speedBoostTimer = 0;
                this.treatsCollected = 0;
                this.currentLevel = 1;
                this.startTime = Date.now();
                this.level = this.createLevel();
                this.fishTreats = this.createFishTreats();
                this.goalReached = false;
                this.initLevel();
                hideWinScreen();
            }
            
            showWinScreen() {
                const time = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('winTime').textContent = time;
                document.getElementById('winScore').textContent = this.score;
                document.getElementById('winHits').textContent = this.hits;
                document.getElementById('winOverlay').style.display = 'block';
            }
        }
        
        let game = null;
        let animationId = null;
        
        function gameLoop() {
            const now = Date.now();
            const dt = Math.min(now - game.lastTime, 100);
            game.lastTime = now;
            
            game.update(dt);
            game.draw();
            
            updateHUD();
            
            if (debugMode) {
                updateDebugOverlay();
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            game = new Game();
            game.lastTime = Date.now();
            gameLoop();
        }
        
        function updateHUD() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('time').textContent = Math.floor((Date.now() - game.startTime) / 1000);
            
            // Show level and speed boost
            const hudExtra = document.getElementById('hudExtra');
            if (!hudExtra) {
                const hud = document.getElementById('hud');
                const extraDiv = document.createElement('div');
                extraDiv.id = 'hudExtra';
                hud.appendChild(extraDiv);
            }
            document.getElementById('hudExtra').innerHTML = `
                <div>Level: ${game.currentLevel}</div>
                ${game.speedBoost > 1 ? `<div style="color:#FFD700">Speed: ${Math.floor(game.speedBoost * 100)}%</div>` : ''}
                ${game.currentLevel === 2 ? `<div>Treats: ${game.treatsCollected}</div>` : ''}
            `;
        }
        
        function updateDebugOverlay() {
            document.getElementById('fps').textContent = game.fps;
            document.getElementById('playerPos').textContent = 
                `${Math.floor(game.player.x)},${Math.floor(game.player.y)}`;
            document.getElementById('playerVel').textContent = 
                `${Math.floor(game.player.vx)},${Math.floor(game.player.vy)}`;
            document.getElementById('playerState').textContent = game.player.state;
        }
        
        function hideWinScreen() {
            document.getElementById('winOverlay').style.display = 'none';
        }
        
        function restartLevel() {
            game.restart();
            hideWinScreen();
        }
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === 'Tab') {
                e.preventDefault();
                toggleMode();
            }
            
            if (e.key === '`') {
                debugMode = !debugMode;
                document.getElementById('debugOverlay').style.display = 
                    debugMode ? 'block' : 'none';
            }
            
            if (isKeyPressed('restart') && game) {
                game.restart();
            }
            
            if (isKeyPressed('mute')) {
                muted = !muted;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        function isKeyPressed(action) {
            return keyMap[action].some(key => keys[key]);
        }
        
        function switchTab(tab) {
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tab === 'editor') {
                document.querySelector('.tab-button:first-child').classList.add('active');
                document.getElementById('editorTab').classList.add('active');
                currentMode = 'editor';
            } else {
                document.querySelector('.tab-button:last-child').classList.add('active');
                document.getElementById('playTab').classList.add('active');
                currentMode = 'play';
                if (!game) {
                    startGame();
                }
            }
        }
        
        function toggleMode() {
            if (currentMode === 'editor') {
                switchTab('play');
            } else {
                switchTab('editor');
            }
        }
        
        function toggleCollapse(element) {
            element.classList.toggle('collapsed');
        }
        
        document.getElementById('sheetA').addEventListener('change', (e) => {
            loadSheet('A', e.target.files[0]);
        });
        
        document.getElementById('sheetB').addEventListener('change', (e) => {
            loadSheet('B', e.target.files[0]);
        });
        
        function loadSheet(sheetId, file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    sheets[sheetId].img = img;
                    
                    const thumbContainer = document.getElementById(`sheet${sheetId}Thumb`);
                    thumbContainer.innerHTML = '';
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = 96;
                    thumbCanvas.height = 96;
                    const thumbCtx = thumbCanvas.getContext('2d');
                    thumbCtx.imageSmoothingEnabled = false;
                    thumbCtx.drawImage(img, 0, 0, 96, 96);
                    thumbContainer.appendChild(thumbCanvas);
                    
                    if (sheetId === 'A') {
                        analyzeAndSetupGrid(img, sheetId);
                    }
                    
                    updateAnimationPreviews();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function analyzeAndSetupGrid(img, sheetId) {
            const cellWidth = img.width / 3;
            const cellHeight = img.height / 3;
            
            currentMapping.cells = [];
            
            const assignments = [
                'dodge_roll', 'run_1', 'idle_sit',
                'run_2', 'run_3', 'idle_sit_front',
                'crouch', 'jump_up', 'fall_down'
            ];
            
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const idx = r * 3 + c;
                    currentMapping.cells.push({
                        r: r + 1,
                        c: c + 1,
                        crop: [
                            Math.floor(c * cellWidth),
                            Math.floor(r * cellHeight),
                            Math.floor(cellWidth),
                            Math.floor(cellHeight)
                        ],
                        assign: assignments[idx],
                        pivot: [0.5, 1],
                        flipX: false
                    });
                }
            }
            
            if (img.width > img.height) {
                const fireballX = Math.floor(cellWidth * 2.3);
                const fireballY = Math.floor(cellHeight * 0.3);
                currentMapping.fireball = {
                    sheet: sheetId,
                    r: 1,
                    c: 3,
                    crop: [fireballX, fireballY, 16, 16]
                };
            }
            
            renderGridEditor();
            saveToLocalStorage();
        }
        
        function renderGridEditor() {
            const container = document.getElementById('gridEditor');
            container.innerHTML = '';
            
            if (!sheets[currentMapping.sheet].img) {
                container.innerHTML = '<p>Load a sprite sheet first</p>';
                return;
            }
            
            currentMapping.cells.forEach((cell, idx) => {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'grid-cell';
                cellDiv.innerHTML = `
                    <h4>Cell ${cell.r},${cell.c}</h4>
                    <select onchange="updateCellAssignment(${idx}, this.value)">
                        <option value="idle_sit" ${cell.assign === 'idle_sit' ? 'selected' : ''}>Idle Sit</option>
                        <option value="idle_sit_front" ${cell.assign === 'idle_sit_front' ? 'selected' : ''}>Idle Front</option>
                        <option value="run_1" ${cell.assign === 'run_1' ? 'selected' : ''}>Run 1</option>
                        <option value="run_2" ${cell.assign === 'run_2' ? 'selected' : ''}>Run 2</option>
                        <option value="run_3" ${cell.assign === 'run_3' ? 'selected' : ''}>Run 3</option>
                        <option value="jump_up" ${cell.assign === 'jump_up' ? 'selected' : ''}>Jump Up</option>
                        <option value="fall_down" ${cell.assign === 'fall_down' ? 'selected' : ''}>Fall Down</option>
                        <option value="crouch" ${cell.assign === 'crouch' ? 'selected' : ''}>Crouch</option>
                        <option value="dodge_roll" ${cell.assign === 'dodge_roll' ? 'selected' : ''}>Dodge Roll</option>
                        <option value="misc" ${cell.assign === 'misc' ? 'selected' : ''}>Misc</option>
                    </select>
                    <div class="cell-controls">
                        <input type="number" value="${cell.crop[0]}" onchange="updateCellCrop(${idx}, 0, this.value)" title="X">
                        <input type="number" value="${cell.crop[1]}" onchange="updateCellCrop(${idx}, 1, this.value)" title="Y">
                        <input type="number" value="${cell.crop[2]}" onchange="updateCellCrop(${idx}, 2, this.value)" title="Width">
                        <input type="number" value="${cell.crop[3]}" onchange="updateCellCrop(${idx}, 3, this.value)" title="Height">
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="flip_${idx}" ${cell.flipX ? 'checked' : ''} 
                               onchange="updateCellFlip(${idx}, this.checked)">
                        <label for="flip_${idx}">Flip X</label>
                    </div>
                    <button onclick="autoTrimCell(${idx})">Auto Trim</button>
                `;
                container.appendChild(cellDiv);
            });
        }
        
        function updateCellAssignment(idx, value) {
            currentMapping.cells[idx].assign = value;
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function updateCellCrop(idx, cropIdx, value) {
            currentMapping.cells[idx].crop[cropIdx] = parseInt(value);
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function updateCellFlip(idx, value) {
            currentMapping.cells[idx].flipX = value;
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function autoTrimCell(idx) {
            const cell = currentMapping.cells[idx];
            const img = sheets[currentMapping.sheet].img;
            if (!img) return;
            
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            const pixels = imageData.data;
            
            let minX = cell.crop[0] + cell.crop[2];
            let minY = cell.crop[1] + cell.crop[3];
            let maxX = cell.crop[0];
            let maxY = cell.crop[1];
            
            for (let y = cell.crop[1]; y < cell.crop[1] + cell.crop[3]; y++) {
                for (let x = cell.crop[0]; x < cell.crop[0] + cell.crop[2]; x++) {
                    const idx = (y * img.width + x) * 4;
                    if (pixels[idx + 3] > 0) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            if (maxX > minX && maxY > minY) {
                cell.crop = [minX, minY, maxX - minX + 1, maxY - minY + 1];
                renderGridEditor();
                updateAnimationPreviews();
                saveToLocalStorage();
            }
        }
        
        function updateAnimationPreviews() {
            const container = document.getElementById('animationPreview');
            container.innerHTML = '';
            
            const states = ['idle_sit', 'run', 'jump_up', 'fall_down', 'crouch', 'dodge_roll'];
            const scales = [1, 2, 4];
            
            states.forEach(state => {
                const frames = getFramesForState(state);
                if (frames.length === 0) return;
                
                scales.forEach(s => {
                    const item = document.createElement('div');
                    item.className = 'anim-preview-item';
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 32 * s;
                    canvas.height = 32 * s;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    
                    let frameIdx = 0;
                    const animate = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        const frame = frames[frameIdx % frames.length];
                        if (frame && sheets[currentMapping.sheet].img) {
                            ctx.drawImage(
                                sheets[currentMapping.sheet].img,
                                frame.crop[0], frame.crop[1], frame.crop[2], frame.crop[3],
                                0, 0, canvas.width, canvas.height
                            );
                        }
                        frameIdx++;
                    };
                    
                    animate();
                    setInterval(animate, 200);
                    
                    const label = document.createElement('label');
                    label.textContent = `${state} ${s}x`;
                    
                    item.appendChild(canvas);
                    item.appendChild(label);
                    container.appendChild(item);
                });
            });
        }
        
        function getFramesForState(state) {
            if (state === 'run') {
                return ['run_1', 'run_2', 'run_3']
                    .map(s => currentMapping.cells.find(c => c.assign === s))
                    .filter(c => c);
            }
            return currentMapping.cells.filter(c => c.assign === state);
        }
        
        function exportSettings() {
            const data = JSON.stringify(currentMapping, null, 2);
            const textarea = document.getElementById('jsonData');
            textarea.value = data;
            textarea.style.display = 'block';
            textarea.select();
            document.execCommand('copy');
            alert('Settings copied to clipboard!');
        }
        
        function importSettings() {
            const textarea = document.getElementById('jsonData');
            textarea.style.display = 'block';
            textarea.value = '';
            textarea.placeholder = 'Paste JSON here and press Enter';
            textarea.focus();
            
            textarea.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    try {
                        const data = JSON.parse(textarea.value);
                        currentMapping = data;
                        renderGridEditor();
                        updateAnimationPreviews();
                        saveToLocalStorage();
                        textarea.style.display = 'none';
                        alert('Settings imported successfully!');
                    } catch (err) {
                        alert('Invalid JSON data');
                    }
                }
            };
        }
        
        function resetDefaults() {
            currentMapping = JSON.parse(JSON.stringify(defaultMapping));
            renderGridEditor();
            updateAnimationPreviews();
            saveToLocalStorage();
        }
        
        function saveToLocalStorage() {
            localStorage.setItem('catPlatformerSettings', JSON.stringify({
                mapping: currentMapping,
                physics: physics,
                keyMap: keyMap,
                scale: scale
            }));
        }
        
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('catPlatformerSettings');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.mapping) currentMapping = data.mapping;
                    if (data.physics) Object.assign(physics, data.physics);
                    if (data.keyMap) Object.assign(keyMap, data.keyMap);
                    if (data.scale) scale = data.scale;
                } catch (err) {
                    console.error('Failed to load settings:', err);
                }
            }
        }
        
        function openKeyRemapping() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #16213e;
                padding: 20px;
                border: 2px solid #0f3460;
                z-index: 1000;
            `;
            
            modal.innerHTML = '<h3>Press a key for each action:</h3>';
            
            const actions = Object.keys(keyMap);
            let currentAction = 0;
            
            const updateModal = () => {
                if (currentAction >= actions.length) {
                    document.body.removeChild(modal);
                    saveToLocalStorage();
                    return;
                }
                
                modal.innerHTML = `
                    <h3>Press a key for: ${actions[currentAction]}</h3>
                    <p>Current: ${keyMap[actions[currentAction]].join(', ')}</p>
                `;
            };
            
            updateModal();
            
            const handleKey = (e) => {
                e.preventDefault();
                keyMap[actions[currentAction]] = [e.key];
                currentAction++;
                updateModal();
                
                if (currentAction >= actions.length) {
                    window.removeEventListener('keydown', handleKey);
                }
            };
            
            window.addEventListener('keydown', handleKey);
            document.body.appendChild(modal);
        }
        
        document.getElementById('gravity').addEventListener('input', (e) => {
            physics.gravity = parseFloat(e.target.value);
            document.getElementById('gravityVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('jumpForce').addEventListener('input', (e) => {
            physics.jumpForce = parseFloat(e.target.value);
            document.getElementById('jumpForceVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('moveSpeed').addEventListener('input', (e) => {
            physics.moveSpeed = parseFloat(e.target.value);
            document.getElementById('moveSpeedVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('friction').addEventListener('input', (e) => {
            physics.friction = parseFloat(e.target.value);
            document.getElementById('frictionVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('coyoteTime').addEventListener('input', (e) => {
            physics.coyoteTime = parseFloat(e.target.value);
            document.getElementById('coyoteVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('jumpBuffer').addEventListener('input', (e) => {
            physics.jumpBuffer = parseFloat(e.target.value);
            document.getElementById('jumpBufferVal').textContent = e.target.value;
            saveToLocalStorage();
        });
        
        document.getElementById('uiScale').addEventListener('input', (e) => {
            scale = parseInt(e.target.value);
            document.getElementById('scaleVal').textContent = scale;
            resizeCanvas();
            saveToLocalStorage();
        });
        
        document.getElementById('highContrast').addEventListener('change', (e) => {
            highContrast = e.target.checked;
            document.body.classList.toggle('high-contrast', highContrast);
        });
        
        document.getElementById('reducedMotion').addEventListener('change', (e) => {
            reducedMotion = e.target.checked;
        });
        
        function resizeCanvas() {
            const maxWidth = window.innerWidth - 370;
            const maxHeight = window.innerHeight - 40;
            
            let width = 400 * scale;
            let height = 240 * scale;
            
            if (width > maxWidth) {
                const ratio = maxWidth / width;
                width = maxWidth;
                height = height * ratio;
            }
            
            if (height > maxHeight) {
                const ratio = maxHeight / height;
                height = maxHeight;
                width = width * ratio;
            }
            
            canvas.width = width;
            canvas.height = height;
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        loadFromLocalStorage();
        resizeCanvas();
        renderGridEditor();
        
        const defaultSheetData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMS42/U4J6AAAB1BJREFUeF7tnT1sVUcQhR+JEEIgIYRAQkghpXtKp6RLSZeO0l06SneUlE5Jl5IuHaW7lJTu0qWkS0mXEiEQAglBBBICCQQS4vvm7F35+fl57+7szOy9u3ekI9vPz3fuzJm9e/funZ37zszMzMzMzFbBNTiCN/AZfsBv+BN/4Rf8iG/wEZ7BMVyz/6kGbuI5fIXfkfs6xnt4CHs70fC7eIFLKHvxpbF8jOv2VTc5iNdYxuJL4yni1n111RLNvoC6Fl8azxO4Zl9dlaQJR5AqniqG1+yrqooc/HeYLp7ahlftr6osn7GuL3+ZWOzrqvATTO/1JNjPViEp5xGM8xnOmu2iZxibyiQFbWMKYtzI6NcJ/0I6YZSPbXuDl/B3+BzMsjJBOOEJJFz1DGRwANI5uyGv4cjGtkPIsIBXaA+iAZ/gHlyEzA+sQj7DzQxn7YUPMHQzDvEawqTGZ7jb0dZN5OiJ+RLHcRSSCfEy7PUE8g6K5gK24TjchRwD5WDfwzGfQQ5fOgdNJBOQxXGQLMJFcDg5irxBjiHEGORQIoerj5BJ0F1Ir2w6sjqUF5BJ0Lfo0OQ2LCCTYCEJvJGk24cwQ0mjuItsA3kNsQo8jvdRdSJdJO5CMOcge3I2Hblo6DQntyF4ZkVyGRU3sALvZP7chhC4KoqiE1o6QzbiKqiCYsOT2xDE9IqhCxs2pCdtMkYnCJ+2RCcI5UQGBdgywVE4fRaUW8QQOm2Qb5i8EJw+CwqEz4LOC8g8CcJMz8SQbkdMzxQIgdNG+ZQlG7EENUQnvdGJPJPgvJjNF4RTRCdt1pV9CCZVKy8o79wQLpoTN/M5CnuQ3EYMgac5OU0LJ1a0F8JnP0nQCHKakE5bQs6BZAW6MJ9hISlqTvhJUBRu4lkT2Fvdxcu2gUyCLszrBEnIOLYJzoNswdkJvFfRCU46r7K+mZf9KEAayJOUO5E8TuiJqBRMOj+zD5Cf0cQcQKA5yI6YYQEfQCa5CZ/VpJxOkGQkBW3Hb1u2DPTDV6nKGJLTMN+JdQ12MKvQJJxykRnRJUi8C4BDEi+eoiEXnJJOgtx9QDQX4LYKFkGUlxCYFESTYJ8aJfhKH/cgzlvJOyUTJp8qC3AO0lGeSMlZzBKkc9iBQLpJL4Z0QNcSIq8TepKwhyC+Ybj8GJZ3jTJJVdCNQkkHdNk2kJcUksQQ7SJBgzCRcgrioJZcOQRFCy+WnNiB+EIl8BLMi/LuHE7CBP4Kx7sjvuHxMCyJtJy3wN9D8lBCkHKaH7TnNvgfhg8hHRgS05gWaBLGzJf8SRnGbp05N/IG4TgPJl8Ax8/OlkRh7Eb79vQJ8oGqxnBJJfhJEGiFlRZ8knCJsQQ/TggVT6iTdJaAFwklKjvNHjvfQd5KFdK5bklI2DhxQvhJzJNrNilOlGLvQBYiJTm8VCDXMqWJ1QVUo5cRJKJqQqBVeSHy0oeqHkbdJoXvCyKBJrwMu8gK+SkxJOkUJ9KhLhgjGlTyFEMQJ9AzIgqg4aMOiSSd4r2nEyWJtIBgC3A0QJNCkkR4CtHy3xHJsC8hdBQFbQTf1fBdJJ1ikNMu0smwb9qnJRnrBOJOQRU38ySRJlnVrHBdJHNyfyQgqz8SQQNyOsGxAUcBMw+qRlqA+xJyOqFyA7jf8n5VGzNu3Ln5p1aSDQCsQzrBnZzQhQF1cQJxhNg3qpMqJAekdT1eQo8kCOfNvOwryNsOhpJ5IaRzKpoQfwTxqOcD+pD5kQnOPcmKcGJFcQH+kJdCJj7D0Y9hCGfxTFSqBdY/I2nMhqScTqhkQnQCcdPuTZmQP7kROoqC5qOLjhgHqRJJP+EpRFWrITKROoG4x88dCHY+YuznQ+gE4TIJnBG9gy4NIH8ZhTKxXMLWYpGcuXTOSTCJlqfBNahvRtRmU6ZuZkT4SRAmkyAq0sSNOAr6HH52JY1bIRkD8Yq4Y5CJAa2SvlLyJiGQbJMAM++Rb7yHOAW9QBdJX5HgqGjBxRCXCGK1F3zZiCr2GzRTRIBn8oOQRU3iyMsm1kNqxkCOxuxNNhGSrGNLI7qx9M0JBzN6TRTqLETQlqLMLUoSvW8cJYM6yEEdhLwQ+QJydBJPhyfJJmXKPFu5oGxlAbmGLIsw1RPnI29QJIdXJcTD5PUy8xDEVDOioQxXNz4j6wRiaIuTz5Ad9iEfzOQKmOtZaExQBu1D5AuaKBLDJdxB8mCZ5HRfznLJbkKhG2MvoyB3pJ9tQ6Hfz7Cd4CxkEDYJ/Rt5+TtQ7jBCdRCRl9WXiQxOlUIXtC9B3O8/R/5g3qCKCUFO6vY9lJPcnhTyKZKi+zMsT7KECZORYTRlZhJOcrwrD7NJK3JENAcQdJJjQgR5KN+YOa0Mk0HV3rz7+y2TNRwXyKUAAAAASUVORK5CYII=';
        
        const img = new Image();
        img.onload = () => {
            sheets.A.img = img;
            analyzeAndSetupGrid(img, 'A');
            
            const thumbContainer = document.getElementById('sheetAThumb');
            thumbContainer.innerHTML = '';
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 96;
            thumbCanvas.height = 96;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.imageSmoothingEnabled = false;
            thumbCtx.drawImage(img, 0, 0, 96, 96);
            thumbContainer.appendChild(thumbCanvas);
        };
        img.src = defaultSheetData;
    </script>
</body>
</html>